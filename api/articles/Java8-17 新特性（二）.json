{"title":"Java8-17 新特性（二）","uid":"cfd6516cec60dd52fbe0026aa3ac0713","slug":"Java8-17 新特性（二）","date":"2023-02-17T08:33:42.000Z","updated":"2023-03-15T03:55:43.663Z","comments":true,"path":"api/articles/Java8-17 新特性（二）.json","keywords":null,"cover":"../images/java.png","content":"<h1 id=\"Java8-17-新特性（二）\"><a href=\"#Java8-17-新特性（二）\" class=\"headerlink\" title=\"Java8-17 新特性（二）\"></a>Java8-17 新特性（二）</h1><h2 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h2><h3 id=\"1-Java平台模块系统-JPMS\"><a href=\"#1-Java平台模块系统-JPMS\" class=\"headerlink\" title=\"1. Java平台模块系统(JPMS)\"></a>1. Java平台模块系统(JPMS)</h3><h4 id=\"1-1-模块\"><a href=\"#1-1-模块\" class=\"headerlink\" title=\"1.1 模块\"></a>1.1 模块</h4><ul>\n<li><em>模块</em>是一个命名的、自描述的代码和数据集合(A <em>module</em> is a named, self-describing collection of code and data.)。它是一组包含类型的包(package)的集合，也包括其他一些静态资源。</li>\n<li>模块可以理解为package的上级容器，可以控制一个package是否对外暴露(exports)，从而实现更精细化的访问控制。</li>\n</ul>\n<h4 id=\"1-2-模块化的使用方式\"><a href=\"#1-2-模块化的使用方式\" class=\"headerlink\" title=\"1.2 模块化的使用方式\"></a>1.2 模块化的使用方式</h4><p>如何把一个普通项目变成模块化项目？</p>\n<ul>\n<li><p>首先添加一个模块描述符(<code>module-info.java</code>)文件，并定义模块名称：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module insoundai.api &#123;\n&#125;</code></pre>\n\n<p>以上我们定义了一个名为<code>insoundai.api</code>的模块。</p>\n</li>\n<li><p>然后暴露(<code>exports</code>)我们需要让别人访问的<strong>包(package)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module insoundai.api &#123;\n    exports com.insoundai.api;\n&#125;</code></pre>\n\n<p>这样别的模块引用<code>insoundai.api</code>模块时，就可以调用<code>com.insoundai.api</code>包下面的类或其他资源了。</p>\n</li>\n<li><p>如果我们需要引用其他模块的类，必须先用<code>requires</code>导入这个<em><strong>模块</strong></em></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module insoundai.api &#123;\n    requires insoundai.util;\n\n    exports com.insoundai.api;\n&#125;</code></pre>\n</li>\n<li><p>有时候，我们希望调用本模块时，被我们引用的模块也能暴露出去。比如我们暴露某个Service，这个Service用到的实体类却是别的模块的，那我们希望Service跟这个实体类一起暴露出去。这时我们可以用<code>requires transitive</code>，来表示这个模块的引用是可以被传递的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module insoundai.api &#123;\n    requires transitive insoundai.persistence;\n    requires insoundai.util;\n\n    exports com.insoundai.api;\n&#125;</code></pre>\n\n<p>当别的模块引用<code>insoundai.api</code>模块时，<code>insoundai.persistence</code>模块会同时被引入。</p>\n</li>\n<li><p>有的模块只需要编译时存在，比如<code>lombok</code>，我们可以用<code>requires static</code>来声明：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module insoundai.persistence &#123;\n    requires static lombok;\n    exports com.insoundai.persistence.entity;\n&#125;</code></pre>\n</li>\n<li><p><code>opens</code>用于声明仅运行时可访问的包，这些包的内容可以通过反射获取。这对Spring项目非常有用，我们声明的<code>Spring Bean</code>都需要通过这种方式让spring调用到。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module insoundai.api &#123;\n    requires transitive insoundai.persistence;\n    requires insoundai.util;\n    requires spring.context;\n\n    opens com.insoundai.api.impl to spring.beans;\n\n    exports com.insoundai.api;\n&#125;</code></pre></li>\n</ul>\n<h4 id=\"1-3-模块化的好处\"><a href=\"#1-3-模块化的好处\" class=\"headerlink\" title=\"1.3 模块化的好处\"></a>1.3 模块化的好处</h4><h5 id=\"1-3-1-可靠性配置\"><a href=\"#1-3-1-可靠性配置\" class=\"headerlink\" title=\"1.3.1. 可靠性配置\"></a>1.3.1. 可靠性配置</h5><p>通过显式地声明组件之间的依赖关系，取代脆弱、易出错的类路径机制。</p>\n<h5 id=\"1-3-2-强封装\"><a href=\"#1-3-2-强封装\" class=\"headerlink\" title=\"1.3.2 强封装\"></a>1.3.2 强封装</h5><p>允许组件声明它的哪些公共类型可以被其他组件访问，哪些不能。</p>\n<h3 id=\"1-4-与Maven多模块的区别\"><a href=\"#1-4-与Maven多模块的区别\" class=\"headerlink\" title=\"1.4 与Maven多模块的区别\"></a>1.4 与Maven多模块的区别</h3><ul>\n<li>Maven的模块都可以作为单独的项目存在，都有自己的pom文件，可以打成单独的jar包。Maven多模块一般只用于复杂的项目，是基于某种缘由对项目的拆分。</li>\n<li>JMPS关注的是项目内包的管理，用来控制项目内的包是否能被外部访问到。</li>\n</ul>\n<h3 id=\"2-JShell\"><a href=\"#2-JShell\" class=\"headerlink\" title=\"2. JShell\"></a>2. JShell</h3><ul>\n<li><p>JShell是一个交互式工具(REPL)。它在输入声明、语句和表达式时计算它们，并立即显示结果。该工具从命令行运行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ jshell\njshell&gt; System.out.println(&quot;hello world&quot;);\nhello world\n\njshell&gt; int x &#x3D; 0;\nx &#x3D;&#x3D;&gt; 0\njshell&gt; for (int i &#x3D; 0;i &lt; 10;i++) &#123;\n   ...&gt;     x +&#x3D; i;\n   ...&gt; &#125;\njshell&gt; System.out.println(x);\n45</code></pre></li>\n</ul>\n<h3 id=\"3-快速创建不可变集合\"><a href=\"#3-快速创建不可变集合\" class=\"headerlink\" title=\"3. 快速创建不可变集合\"></a>3. 快速创建不可变集合</h3><ul>\n<li><p>增加了<code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nMap.of(&quot;k1&quot;, &quot;val1&quot;, &quot;k2&quot;, &quot;val2&quot;);</code></pre></li>\n</ul>\n<h2 id=\"Java10\"><a href=\"#Java10\" class=\"headerlink\" title=\"Java10\"></a>Java10</h2><h3 id=\"局部变量类型推断\"><a href=\"#局部变量类型推断\" class=\"headerlink\" title=\"局部变量类型推断\"></a>局部变量类型推断</h3><ul>\n<li><p>Java10提供了局部变量的类型推断。局部变量初始化时，可以用<code>var</code>替代显式的变量类型声明。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">var text &#x3D; &quot;Hello World!&quot;;</code></pre>\n</li>\n<li><p><code>var</code>不是关键字，而是保留的类型名称。这保证了<code>var</code>作为函数名或变量名的向后兼容性。</p>\n</li>\n<li><p>变量的类型信息会在编译时通过等号右侧信息推断出来，因此<code>var</code>的使用不会对Java运行时的性能产生影响，也不会使Java变成动态语言。</p>\n</li>\n<li><p><code>var</code>是一把双刃剑，使用得当会有效提升代码的可读性，使用不好则会让代码可读性变得更差。以下是一些使用建议：</p>\n<ol>\n<li><p>变量命名中提供了足够的信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 显式类型\nList&lt;User&gt; list &#x3D; obj.handle();\n\n&#x2F;&#x2F; var方式\nvar userList &#x3D; obj.handle();</code></pre>\n</li>\n<li><p>变量初始化过程中包含了足够的信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 显式类型\nByteArrayOutputStream outputStream &#x3D; new ByteArrayOutputStream();\nList&lt;String&gt; stringList &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\n&#x2F;&#x2F; var方式\nvar outputStream &#x3D; new ByteArrayOutputStream();\nvar stringList &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></pre>\n</li>\n<li><p>for循环或try-with-resources中，可以考虑使用<code>var</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 显式类型\nfor (Iterator&lt;String&gt; iterator &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).iterator(); iterator.hasNext();) &#123;\n    String string &#x3D; iterator.next();\n&#125;\n&#x2F;&#x2F; var方式\nfor (var iterator &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).iterator(); iterator.hasNext();) &#123;\n    var userType &#x3D; iterator.next();\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p><code>var</code>的错误用法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">var a; &#x2F;&#x2F; 没有初始化变量\nvar b &#x3D; null; &#x2F;&#x2F; 不能初始化为null\npublic var c &#x3D; &quot;d&quot;; &#x2F;&#x2F; 不能用于非局部变量\nvar e &#x3D; (String s) -&gt; s.length() &gt; 1; &#x2F;&#x2F; lambda表达式需要显式类型信息\nvar arr &#x3D; &#123;1, 2, 3&#125; &#x2F;&#x2F; 不能用于数组初始化</code></pre></li>\n</ul>\n<h2 id=\"Java11\"><a href=\"#Java11\" class=\"headerlink\" title=\"Java11\"></a>Java11</h2><h3 id=\"1-String新方法\"><a href=\"#1-String新方法\" class=\"headerlink\" title=\"1. String新方法\"></a>1. String新方法</h3><h4 id=\"1-1-repeat\"><a href=\"#1-1-repeat\" class=\"headerlink\" title=\"1.1  repeat()\"></a>1.1  repeat()</h4><ul>\n<li>将字符串重复n次</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;呼&quot;.repeat(2) + &quot;大睡&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt; &quot;呼呼大睡&quot;</code></pre>\n\n<h4 id=\"1-2-strip系列方法\"><a href=\"#1-2-strip系列方法\" class=\"headerlink\" title=\"1.2  strip系列方法\"></a>1.2  strip系列方法</h4><ul>\n<li>去除头尾的空格，包括<code>strip()</code>, <code>stripLeading()</code>, <code>stripTrailing()</code>三个方法。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;\\n\\t  hello  \\u2005\\u001C&quot;;\nSystem.out.println(text.strip().equals(&quot;hello&quot;));\n\n&gt;&gt;&gt; true</code></pre>\n\n<ul>\n<li>与<code>trim()</code>的不同点<ul>\n<li>trim() 方法判断空格的依据是Unicode代码小于或等于空格符(U+0020)，包括常见的换行符和Tab。</li>\n<li>strip() 方法的判断依据是<code>Character.isWhitespace()</code>方法，即Unicode空白字符串，范围更广。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-3-isBlank-方法\"><a href=\"#1-3-isBlank-方法\" class=\"headerlink\" title=\"1.3  isBlank()方法\"></a>1.3  isBlank()方法</h4><ul>\n<li>判断字符串是否为空或只包含空格，空格的判断与<code>strip()</code>相同。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;\\n\\t\\u2005  &quot;;\nSystem.out.println(&quot;\\n\\t\\u2005  &quot;.isBlank());\n\n&gt;&gt;&gt; true</code></pre>\n\n<h4 id=\"1-4-lines-方法\"><a href=\"#1-4-lines-方法\" class=\"headerlink\" title=\"1.4  lines() 方法\"></a>1.4  lines() 方法</h4><ul>\n<li>通过行终止符(<code>\\n</code>, <code>\\r</code>或<code>\\r\\n</code>)分割字符串，并返回一个 <code>Stream</code>。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;每天\\n都能\\r准时\\r\\n下班&quot;;\nList&lt;String&gt; lines &#x3D; text.lines().collect(Collectors.toList());\nSystem.out.println(lines);\n\n&gt;&gt;&gt; [每天, 都能, 准时, 下班]</code></pre>\n\n<h3 id=\"2-Http-Client\"><a href=\"#2-Http-Client\" class=\"headerlink\" title=\"2. Http Client\"></a>2. Http Client</h3><ul>\n<li><p>Java11 提供了新的Http客户端，实现了Http和WebSocket的客户端API标准化。</p>\n</li>\n<li><p>新的 API 为 HTTP 1.1&#x2F;2和WebSocket 提供了原生支持。提供核心功能的核心类和接口包括：</p>\n<ul>\n<li><p><em>HttpClient</em>类，<em>java.net.http.HttpClient</em></p>\n</li>\n<li><p><em>HttpRequest</em>类，<em>java.net.http.HttpRequest</em></p>\n</li>\n<li><p><em>HttpResponse</em> <T>接口，<em>java.net.http.HttpResponse</em></p>\n</li>\n<li><p><em>WebSocket</em>接口，<em>java.net.http.WebSocket</em></p>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建 httpRequest\nHttpRequest request &#x3D; HttpRequest.newBuilder()\n    .uri(new URI(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;test&#x2F;1&quot;))\n    .header(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)\n    .header(&quot;Accept&quot;, &quot;application&#x2F;json&quot;)\n    .timeout(Duration.ofSeconds(10))\n    .POST(HttpRequest.BodyPublishers.ofString(&quot;&#123;\\&quot;score\\&quot;:\\&quot;1\\&quot;&#125;&quot;))\n    .build();\n&#x2F;&#x2F; 创建 httpClient\nHttpClient client &#x3D; HttpClient.newHttpClient();\n&#x2F;&#x2F; 由httpClient发送请求，获取响应数据\nHttpResponse&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());\nHttpHeaders headers &#x3D; response.headers();\nString body &#x3D; response.body();</code></pre>\n\n\n\n<h3 id=\"3-Java文件运行方式\"><a href=\"#3-Java文件运行方式\" class=\"headerlink\" title=\"3. Java文件运行方式\"></a>3. Java文件运行方式</h3><p>Java11之前需要用<code>javac</code>编译源文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ javac HelloWorld.java\n$ java HelloWorld\n\nHello Java 8!</code></pre>\n\n<p>现在可以直接运行Java文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ java HelloWorld.java\n\nHello Java 11!</code></pre>\n\n<h3 id=\"4-OpenJDK\"><a href=\"#4-OpenJDK\" class=\"headerlink\" title=\"4. OpenJDK\"></a>4. OpenJDK</h3><ul>\n<li>Java11 开始，Oracle JDK 与 OpenJDK 已没有本质的区别</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://inside.java/2021/09/10/what-are-modules-about/\">What Modules Are About</a></li>\n<li><a href=\"https://openjdk.org/projects/jigsaw/spec/sotms/2015-09-08\">The State of the Module System</a></li>\n<li><a href=\"https://juejin.cn/post/7074501951748046884\">Java9新特性中的模块化到底是什么</a></li>\n<li><a href=\"https://www.baeldung.com/project-jigsaw-java-modularity\">Introduction to Project Jigsaw</a></li>\n<li><a href=\"https://openjdk.org/projects/amber/guides/lvti-style-guide\">局部变量类型推断风格指南</a></li>\n</ol>\n","text":"Java8-17 新特性（二）Java91. Java平台模块系统(JPMS)1.1 模块 模块是一个命名的、自描述的代码和数据集合(A module is a named, self-describing collection of code and data.)。它是一组包含...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":9,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":10,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java8-17-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89\"><span class=\"toc-text\">Java8-17 新特性（二）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java9\"><span class=\"toc-text\">Java9</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Java%E5%B9%B3%E5%8F%B0%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F-JPMS\"><span class=\"toc-text\">1. Java平台模块系统(JPMS)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1.1 模块</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1.2 模块化的使用方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">1.3 模块化的好处</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-1-%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.3.1. 可靠性配置</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-3-2-%E5%BC%BA%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">1.3.2 强封装</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E4%B8%8EMaven%E5%A4%9A%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.4 与Maven多模块的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-JShell\"><span class=\"toc-text\">2. JShell</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88\"><span class=\"toc-text\">3. 快速创建不可变集合</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java10\"><span class=\"toc-text\">Java10</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">局部变量类型推断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java11\"><span class=\"toc-text\">Java11</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-String%E6%96%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1. String新方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-repeat\"><span class=\"toc-text\">1.1  repeat()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-strip%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2  strip系列方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-isBlank-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.3  isBlank()方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-lines-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.4  lines() 方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Http-Client\"><span class=\"toc-text\">2. Http Client</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Java%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3. Java文件运行方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-OpenJDK\"><span class=\"toc-text\">4. OpenJDK</span></a></li></ol></li></ol></li></ol>","author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/wch2019","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2019"}}}},"mapped":true,"prev_post":{"title":"nvm for windows 下载、安装及使用","uid":"d459146c27d3881c39d30204014457f4","slug":"nvm for windows 下载、安装及使用","date":"2023-02-26T10:19:42.000Z","updated":"2023-03-16T07:30:46.435Z","comments":true,"path":"api/articles/nvm for windows 下载、安装及使用.json","keywords":null,"cover":"../images/nodejs.png","text":"nvm for windows 下载、安装及使用 nvm是node版本管理工具，可以运行在多种操作系统上。这里主要记录一下在windows系统的安装和使用。 下载NVM for Windows 下载地址： github.com&#x2F;coreybutler… 只需点击第三个，...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"web","slug":"web","count":7,"path":"api/categories/web.json"}],"tags":[{"name":"web","slug":"web","count":7,"path":"api/tags/web.json"}],"author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/wch2019","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2019"}}}}},"next_post":{"title":"Java8-17 新特性（一）","uid":"a4afb430c2cbd3b47233ae51001f2621","slug":"Java8-17 新特性（一）","date":"2023-02-17T07:33:42.000Z","updated":"2023-03-15T03:55:23.647Z","comments":true,"path":"api/articles/Java8-17 新特性（一）.json","keywords":null,"cover":"../images/java.png","text":"Java8-17 新特性（一）Java81. 接口默认方法和静态方法 1.1 默认方法默认方法需要用新的关键字default来定义。默认方法可以通过实现类的实例进行访问，并且可以被重写。 public interface UserDao &#123; default Option...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"Java","slug":"Java","count":9,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":10,"path":"api/tags/Java.json"}],"author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/wch2019","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2019"}}}}}}