{"title":"Java8-17 新特性（一）","uid":"a4afb430c2cbd3b47233ae51001f2621","slug":"Java8-17 新特性（一）","date":"2023-02-17T07:33:42.000Z","updated":"2023-03-15T03:55:23.647Z","comments":true,"path":"api/articles/Java8-17 新特性（一）.json","keywords":null,"cover":"../images/java.png","content":"<h1 id=\"Java8-17-新特性（一）\"><a href=\"#Java8-17-新特性（一）\" class=\"headerlink\" title=\"Java8-17 新特性（一）\"></a>Java8-17 新特性（一）</h1><h2 id=\"Java8\"><a href=\"#Java8\" class=\"headerlink\" title=\"Java8\"></a>Java8</h2><h3 id=\"1-接口默认方法和静态方法\"><a href=\"#1-接口默认方法和静态方法\" class=\"headerlink\" title=\"1. 接口默认方法和静态方法\"></a>1. 接口默认方法和静态方法</h3><ul>\n<li><h4 id=\"1-1-默认方法\"><a href=\"#1-1-默认方法\" class=\"headerlink\" title=\"1.1 默认方法\"></a>1.1 默认方法</h4><p>默认方法需要用新的关键字<code>default</code>来定义。默认方法可以通过实现类的实例进行访问，并且可以被重写。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDao &#123;\n    default Optional&lt;User&gt; getUserByUsername(String username) &#123;\n        User user &#x3D; new User();\n        user.setUsername(username);\n        return Optional.of(user);\n    &#125;\n&#125;</code></pre>\n</li>\n<li><h4 id=\"1-2-静态方法\"><a href=\"#1-2-静态方法\" class=\"headerlink\" title=\"1.2 静态方法\"></a>1.2 静态方法</h4><p>静态方法不能被重写。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDao &#123;\n    \n    static Optional&lt;User&gt; getUser(String username) &#123;\n        return Optional.of(new User());\n    &#125;\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"2-函数式接口\"><a href=\"#2-函数式接口\" class=\"headerlink\" title=\"2. 函数式接口\"></a>2. 函数式接口</h3><ul>\n<li><p>函数式接口是指只包含一个抽象方法的接口。函数式接口可以存在多个默认方法，因为它并不是抽象方法。</p>\n</li>\n<li><p>函数式接口一般通过<code>@FunctionalInterface</code>来声明，但该注解并不是必须的，只要符合上述定义的接口都会被编译器认为是函数式接口。</p>\n</li>\n<li><p>函数式接口的实例可以通过lambda表达式、方法引用或构造函数引用来创建。</p>\n</li>\n<li><p>函数式接口有几种基础的形态：</p>\n<ul>\n<li><code>Function</code> —— 一元函数，接受一个参数并返回一个结果</li>\n<li><code>Consumer</code> —— 一元函数，接受一个参数，但不返回任何结果</li>\n<li><code>Predicate</code> —— 一元函数，表示一个参数的断言，返回布尔值</li>\n<li><code>Supplier</code> —— 零元函数，结果的提供者，不接受参数，只返回结果</li>\n</ul>\n</li>\n<li><p>特定的前缀表示了对基础形态特定的扩展</p>\n<ul>\n<li>带元数的前缀，比如Bi前缀，代表二元函数(binary function)，<code>BiConsumer</code>代表接受两个参数，但不返回任何结果</li>\n<li>带类型的前缀，分两种，前缀如果是ToXxx，代表返回值类型是Xxx，否则代表入参的类型。例如<code>ObjIntConsumer</code>代表接受一个泛型参数和int类型参数，<code>ToIntFunction</code>表示返回值是int类型。</li>\n<li>其他派生函数，包括<code>UnaryOperator</code>(extends <code>Function</code>)和<code>BinaryOperator</code>(extends <code>BiFunction</code>)，这两种函数输入值与输出值的类型是一致的。</li>\n</ul>\n</li>\n<li></li>\n</ul>\n<h3 id=\"3-Lambda表达式\"><a href=\"#3-Lambda表达式\" class=\"headerlink\" title=\"3. Lambda表达式\"></a>3. Lambda表达式</h3><h4 id=\"3-1-lambda表达式\"><a href=\"#3-1-lambda表达式\" class=\"headerlink\" title=\"3.1 lambda表达式\"></a>3.1 lambda表达式</h4><ul>\n<li><p>lambda 表达式是一个可传递的代码块，也被称为闭包(<em>closures</em>)或匿名方法(<em>anonymous methods</em>)。</p>\n</li>\n<li><p>lambda具有更强的表现力和更简洁的代码，使我们更加关注做什么而非怎么做。</p>\n</li>\n<li><p>lambda 本质上由三部分组成：一组带括号的参数、一个箭头和一个主体，它可以是单个表达式或 Java 代码块。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Runnable r &#x3D; () -&gt; &#123;&#125;;</code></pre></li>\n</ul>\n<h4 id=\"3-2-方法引用\"><a href=\"#3-2-方法引用\" class=\"headerlink\" title=\"3.2 方法引用\"></a>3.2 方法引用</h4><p><strong>方法引用是一种特殊类型的 lambda 表达式</strong>。它们通常用于通过引用现有方法来创建简单的 lambda 表达式。</p>\n<p>方法引用有四种：</p>\n<ul>\n<li><p>静态方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; System.out.println(&quot;&quot;);\nList.of(&quot;a&quot;, &quot;b&quot;).forEach(System.out::println);</code></pre>\n</li>\n<li><p>特定对象的实例方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Comparator &#123;\n    public int compare(User a, User b) &#123;\n        return a.getAge().compareTo(b.getAge());\n    &#125;\n&#125;\n\n@Data\npublic class User &#123;\n    public User() &#123;\n    &#125;\n    public User(String username, Integer age) &#123;\n        this.username &#x3D; username;\n        this.age &#x3D; age;\n    &#125;\n    private String username;\n    private Integer age;\n\n    public static void main(String[] args) &#123;\n        Comparator comparator &#x3D; new Comparator();\n        List&lt;User&gt; list &#x3D; Stream.of(new User(&quot;a&quot;, 42), new User(&quot;b&quot;, 23))\n                .sorted(comparator::compare)\n                .collect(Collectors.toList());\n        System.out.println(list);\n    &#125;\n&#125;\n&gt;&gt;&gt; [User(username&#x3D;b, age&#x3D;23), User(username&#x3D;a, age&#x3D;42)]</code></pre>\n\n\n</li>\n<li><p>特定类型的任意对象的实例方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; &quot;a&quot;.toUpperCase();\nList&lt;String&gt; list &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;).map(String::toUpperCase).collect(Collectors.toList());\nSystem.out.println(list);</code></pre>\n\n\n</li>\n<li><p>构造函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n    public User() &#123;\n    &#125;\n    public User(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n    private String username;\n&#125;\n\npublic static void main(String[] args) &#123;\n    List&lt;User&gt; list &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;).map(User::new).collect(Collectors.toList());\n    System.out.println(list);\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"4-Streams\"><a href=\"#4-Streams\" class=\"headerlink\" title=\"4. Streams\"></a>4. Streams</h3><ul>\n<li><p>Java的流(Stream)，遵循“做什么而非怎么做”的原则。</p>\n</li>\n<li><p>流管道包括一个源（数组、集合、生成器函数、I&#x2F;O通道等）、零个或多个中间操作（<code>intermediate operation</code>，将一个流转换为另一个流）和一个终端操作（产出结果）</p>\n</li>\n<li><p>流是惰性的，仅在启动终端操作时才对源数据进行计算，并且仅在需要时使用源数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)\n    .filter(s -&gt; &#123;\n        System.out.println(&quot;filter: &quot; + s);\n        return s.startsWith(&quot;a&quot;); \n    &#125;)\n    .map(s -&gt; &#123;\n        System.out.println(&quot;map: &quot; + s);\n        return s.toUpperCase();\n    &#125;)\n    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));\n\n</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)\n    .sorted((s1, s2) -&gt; &#123;\n        System.out.printf(&quot;sort: %s; %s\\n&quot;, s1, s2);\n        return s1.compareTo(s2); \n    &#125;) \n    .filter(s -&gt; &#123;\n        System.out.println(&quot;filter: &quot; + s);\n        return s.startsWith(&quot;a&quot;); \n    &#125;)\n    .map(s -&gt; &#123;\n        System.out.println(&quot;map: &quot; + s);\n        return s.toUpperCase(); \n    &#125;)\n    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;&#x2F; 第一个结果\nfilter: d2\nfilter: a2\nmap: a2\nforEach: A2\nfilter: b1\nfilter: b3\nfilter: c\n\n&#x2F;&#x2F; 第二个结果\nsort: a2; d2\nsort: b1; a2\nsort: b1; d2\nsort: b1; a2\nsort: b3; b1\nsort: b3; d2\nsort: c; b3\nsort: c; d2\nfilter: a2\nmap: a2\nforEach: A2\nfilter: b1\nfilter: b3\nfilter: c\nfilter: d2</code></pre>\n</li>\n<li><p>流是不能被复用的，一旦你调用任何终端操作，流就会关闭</p>\n</li>\n<li><p>常用的中间操作有：<code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>sorted</code>, <code>peek</code>, <code>limit</code>, <code>skip</code>, <code>distinct</code>等</p>\n</li>\n<li><p>常用的终端操作有：<code>forEach</code>, <code>toArray</code>, <code>reduce</code>, <code>collect</code>, <code>min</code>, <code>max</code>, <code>findFirst</code>, <code>count</code>, <code>anyMatch</code>等</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;List&lt;String&gt;&gt; list &#x3D; List.of(List.of(&quot;a&quot;, &quot;b&quot;), List.of(&quot;c&quot;, &quot;d&quot;));\nlist.stream()\n    .flatMap(l -&gt; &#123;\n            System.out.println(&quot;flat map: &quot; + l);\n            return l.stream();\n        &#125;)\n        .map(s -&gt; &#123;\n            System.out.println(&quot;map: &quot; + s);\n            return s.toUpperCase();\n        &#125;)\n        .forEach(System.out::println);\n\n&gt;&gt;&gt; flat map: [a, b]\nmap: a\nA\nmap: b\nB\nflat map: [c, d]\nmap: c\nC\nmap: d\nD</code></pre></li>\n</ul>\n<h3 id=\"5-Optional-lt-T-gt\"><a href=\"#5-Optional-lt-T-gt\" class=\"headerlink\" title=\"5. Optional&lt;T&gt;\"></a>5. <code>Optional&lt;T&gt;</code></h3><ul>\n<li>Optional为空指针(NPE)问题提供了一种解决方案。它用<code>Optional.empty()</code>取代<code>null</code>，以避免null值的判断。</li>\n<li>Java 发布Optional的目的 是将其用作<strong>返回类型</strong>，从而表明方法可以返回空值。这显式地指出了可能的空指针问题。建议可能为<code>null</code>的返回值都使用Optional。</li>\n<li>类的内部不要使用Optional。</li>\n<li>集合内不要放置Optional对象，也不要用作map的key。</li>\n<li>不要直接调用 get()方法，应当先判断值是否存在或者调用orElseThrow()，orElse()或orElseGet()方法。</li>\n</ul>\n<h3 id=\"6-Date-x2F-Time-API\"><a href=\"#6-Date-x2F-Time-API\" class=\"headerlink\" title=\"6. Date&#x2F;Time API\"></a>6. Date&#x2F;Time API</h3><h4 id=\"6-1-与原有api的对比\"><a href=\"#6-1-与原有api的对比\" class=\"headerlink\" title=\"6.1 与原有api的对比\"></a>6.1 与原有api的对比</h4><p>新的API遵循<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\">ISO 8601</a>标准，设计更加清晰，简化了日期和时间的处理。新API的设计借鉴了第三方库<code>JodaTime</code>。</p>\n<ul>\n<li><p>线程安全问题。新API中所有的日期时间都是不可变的，因此是线程安全的。Date和Calendar的值都是可以直接被修改的，可能出现潜在的线程安全问题。</p>\n</li>\n<li><p>原有API有一些糟糕的设计，例如<code>java.util.date</code>年份从 1900 开始，月份从 0开始，日期从 1 开始。打印信息可读性较差。新的api则非常清晰。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Date date &#x3D; new Date(2023, 2, 15);\nSystem.out.println(date);\n&gt;&gt;&gt; Thu Mar 15 00:00:00 CST 3923\n\nCalendar calendar &#x3D; Calendar.getInstance();\ncalendar.set(2023, 2, 15);\nSystem.out.println(calendar.getTime());\n&gt;&gt;&gt; Wed Mar 15 10:55:20 CST 2023\n\nvar localDateTime &#x3D; LocalDateTime.of(2023, 2, 15, 11, 13, 45);\nSystem.out.println(localDateTime);\n&gt;&gt;&gt; 2023-02-15T11:13:45</code></pre>\n</li>\n<li><p>新的api可以使用不同的日历系统。</p>\n</li>\n</ul>\n<h4 id=\"6-2-新的日期-x2F-时间API\"><a href=\"#6-2-新的日期-x2F-时间API\" class=\"headerlink\" title=\"6.2 新的日期&#x2F;时间API\"></a>6.2 新的日期&#x2F;时间API</h4><ul>\n<li><em>Instant——</em>代表一个时间点（timestamp）</li>\n<li><em>LocalDate——</em>代表本地日期（年、月、日）</li>\n<li><em>LocalDateTime</em> – 本地日期时间，时间为纳秒精度</li>\n<li>OffsetDateTime – 具有时区偏移的日期时间</li>\n<li><em>LocalTime</em> – 具有纳秒精度且没有日期信息的时间</li>\n<li><em>ZonedDateTime</em> – 与<em>OffsetDateTime</em>类似，但包括时区 ID</li>\n<li><em>OffsetLocalTime – 与LocalTime</em>类似，但具有时区偏移</li>\n<li><em>MonthDay</em> – 月份和日期，没有年份或时间</li>\n<li><em>YearMonth</em> – 月份和年份，没有日期或时间</li>\n<li><em>Duration</em>——以秒、分钟和小时表示的时间量。具有纳秒精度</li>\n<li><em>Period</em>——以天、月和年表示的时间量</li>\n</ul>\n<h4 id=\"6-3-常用操作\"><a href=\"#6-3-常用操作\" class=\"headerlink\" title=\"6.3 常用操作\"></a>6.3 常用操作</h4><p>LocalDateTime可以认为是LocalDate+LocalTime，这里以LocalDateTime为例。</p>\n<ul>\n<li><p>LocalDateTime</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 指定日期时间\nvar localDateTime &#x3D; LocalDateTime.of(2023, 2, 15, 11, 13, 45);\n&#x2F;&#x2F; 当前日期时间\nvar now &#x3D; LocalDateTime.now();\n&#x2F;&#x2F; 获取年份\nint year &#x3D; now.getYear();\n&#x2F;&#x2F; 获取月份\nMonth month &#x3D; now.getMonth();\n&#x2F;&#x2F; 获取日期\nint day &#x3D; now.getDayOfMonth();\n&#x2F;&#x2F; 获取星期几\nDayOfWeek dayOfWeek &#x3D; now.getDayOfWeek();\n&#x2F;&#x2F;获取小时\nint hour &#x3D; now.getHour();\n&#x2F;&#x2F;获取分\nint minute &#x3D; now.getMinute();\n&#x2F;&#x2F;获取秒\nint second &#x3D; now.getSecond();\n&#x2F;&#x2F; 以上日期时间也可以通过枚举类ChronoField获取\nint month1 &#x3D; now.get(ChronoField.MONTH_OF_YEAR);</code></pre>\n</li>\n<li><p>Instant</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 当前时间点\nInstant instant &#x3D; Instant.now();\n&#x2F;&#x2F; 时间戳\nlong seconds &#x3D; instant.getEpochSecond();\nlong milliseconds &#x3D; instant.toEpochMilli();</code></pre>\n</li>\n<li><p>时间格式化</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">var datetimeFormatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\nString formatTime &#x3D; LocalDateTime.now().format(datetimeFormatter);\nvar parseTime &#x3D; LocalDateTime.parse(&quot;2023-02-11 11:20:12&quot;, datetimeFormatter);</code></pre>\n</li>\n<li><p>对日期时间的操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 可以用with*方法修改时间\nLocalDateTime happyTime &#x3D; LocalDateTime.now().withHour(18).withMinute(0).withSecond(0);\nSystem.out.println(happyTime);\n&gt;&gt;&gt; 2023-02-15T18:00:00.909434200\n&#x2F;&#x2F; 可以用TemporalAdjusters修改时间，比如获取当月最后一天\nLocalDateTime lastDayOfMonth &#x3D; LocalDateTime.now().with(TemporalAdjusters.lastDayOfMonth());\nSystem.out.println(lastDayOfMonth);\n&gt;&gt;&gt; 2023-02-28T13:50:46.909434200\n&#x2F;&#x2F; 获取下一个周五的时间\nLocalDateTime nextFriday &#x3D; LocalDateTime.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY));\nSystem.out.println(nextFriday);\n&gt;&gt;&gt; 2023-02-17T13:50:46.910434500\n&#x2F;&#x2F; 10天后，可以直接调用plusDays方法\nLocalDateTime afterTenDays &#x3D; LocalDateTime.now().plusDays(10);\nSystem.out.println(afterTenDays);\n&gt;&gt;&gt; 2023-02-20T13:55:20.574507300\n&#x2F;&#x2F; 10天前，除了minusDays，也可以手动指定单位\nLocalDateTime beforeTenDays &#x3D; LocalDateTime.now().minus(10, ChronoUnit.DAYS);</code></pre></li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><p><a href=\"https://www.baeldung.com/java-8-new-features\">New Features in Java 8</a></p>\n</li>\n<li><p><a href=\"https://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html\">Java SE 8 Optional, a pragmatic approach</a></p>\n</li>\n</ol>\n","text":"Java8-17 新特性（一）Java81. 接口默认方法和静态方法 1.1 默认方法默认方法需要用新的关键字default来定义。默认方法可以通过实现类的实例进行访问，并且可以被重写。 public interface UserDao &#123; default Option...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"Java","slug":"Java","count":9,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":10,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java8-17-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89\"><span class=\"toc-text\">Java8-17 新特性（一）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java8\"><span class=\"toc-text\">Java8</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1. 接口默认方法和静态方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.1 默认方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2 静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2. 函数式接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">3. Lambda表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">3.1 lambda表达式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">3.2 方法引用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Streams\"><span class=\"toc-text\">4. Streams</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Optional-lt-T-gt\"><span class=\"toc-text\">5. Optional&lt;T&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Date-x2F-Time-API\"><span class=\"toc-text\">6. Date&#x2F;Time API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-%E4%B8%8E%E5%8E%9F%E6%9C%89api%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">6.1 与原有api的对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F-x2F-%E6%97%B6%E9%97%B4API\"><span class=\"toc-text\">6.2 新的日期&#x2F;时间API</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-3-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">6.3 常用操作</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/xiaohai-store","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2020"}}}},"mapped":true,"prev_post":{"title":"Java8-17 新特性（二）","uid":"cfd6516cec60dd52fbe0026aa3ac0713","slug":"Java8-17 新特性（二）","date":"2023-02-17T08:33:42.000Z","updated":"2023-03-15T03:55:43.663Z","comments":true,"path":"api/articles/Java8-17 新特性（二）.json","keywords":null,"cover":"../images/java.png","text":"Java8-17 新特性（二）Java91. Java平台模块系统(JPMS)1.1 模块 模块是一个命名的、自描述的代码和数据集合(A module is a named, self-describing collection of code and data.)。它是一组包含...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":9,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":10,"path":"api/tags/Java.json"}],"author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/xiaohai-store","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2020"}}}}},"next_post":{"title":"树型结构","uid":"f2f9e3dbcdd8dee08b2c8bdbc160f6ea","slug":"树型结构","date":"2022-08-10T02:33:42.000Z","updated":"2023-03-15T05:11:52.124Z","comments":true,"path":"api/articles/树型结构.json","keywords":null,"cover":"../images/java.png","text":"树型结构&#x2F;** * 获取组织机构树 * * @author yuxuange * @Date 2021-02-03 *&#x2F; @Component public class TreeUtil &#123; &#x2F;** * 组织机构表，根节点CODE *&#x...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"Java","slug":"Java","count":9,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":10,"path":"api/tags/Java.json"}],"author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/xiaohai-store","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2020"}}}}}}