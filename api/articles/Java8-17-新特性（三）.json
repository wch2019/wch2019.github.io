{"title":"Java8-17 新特性（三）","uid":"4d03f17c3d855329753f1c2802880b5c","slug":"Java8-17-新特性（三）","date":"2023-03-28T02:44:29.000Z","updated":"2023-03-28T03:57:41.281Z","comments":true,"path":"api/articles/Java8-17-新特性（三）.json","keywords":null,"cover":"../images/java.png","content":"<h1 id=\"Java8-17-新特性（三）\"><a href=\"#Java8-17-新特性（三）\" class=\"headerlink\" title=\"Java8-17 新特性（三）\"></a>Java8-17 新特性（三）</h1><h2 id=\"1-新的switch表达式\"><a href=\"#1-新的switch表达式\" class=\"headerlink\" title=\"1. 新的switch表达式\"></a>1. 新的switch表达式</h2><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><ul>\n<li>新的 switch 表达式在 Java12 中作为预览功能引入，在 Java14 中成为正式功能</li>\n</ul>\n<h2 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h2><ul>\n<li>原有的 switch 表达式写法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DayOfWeek dayOfWeek &#x3D; LocalDate.now().getDayOfWeek();\nString typeOfDay;\nswitch (dayOfWeek) &#123;\n    case MONDAY:\n    case TUESDAY:\n    case WEDNESDAY:\n    case THURSDAY:\n    case FRIDAY:\n        typeOfDay &#x3D; &quot;Working Day&quot;;\n        break;\n    case SATURDAY:\n    case SUNDAY:\n        typeOfDay &#x3D; &quot;Day Off&quot;;\n&#125;</code></pre>\n\n<ul>\n<li>新的 switch 表达式可以直接返回表达式的结果</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String typeOfDay &#x3D; switch (dayOfWeek) &#123;\n\tcase MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;\n\tcase SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;\n&#125;;</code></pre>\n<ul>\n<li>新表达式支持yield字段</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String typeOfDay &#x3D; switch (dayOfWeek) &#123;\n    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &#123;\n        System.out.println(&quot;working day&quot;);\n        yield &quot;Working Day&quot;;\n    &#125;\n    case SATURDAY, SUNDAY -&gt; &#123;\n        System.out.println(&quot;day off&quot;);\n        yield &quot;Day Off&quot;;\n    &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>也可以不返回任何结果</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">switch (dayOfWeek) &#123;\n    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt;\n            System.out.println(&quot;Working Day&quot;);\n    case SATURDAY, SUNDAY -&gt; System.out.println(&quot;Day Off&quot;);\n&#125;</code></pre>\n\n\n\n<h2 id=\"2-文本块\"><a href=\"#2-文本块\" class=\"headerlink\" title=\"2. 文本块\"></a>2. 文本块</h2><h3 id=\"1-简介-1\"><a href=\"#1-简介-1\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><ul>\n<li>文本块( text blocks )在 Java13 中首次引入，在 Java15 中成为正式特性。</li>\n</ul>\n<h3 id=\"2-用法-1\"><a href=\"#2-用法-1\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><ul>\n<li><p>文本块以 “”” (三个双引号)开头，后跟一个换行符。文本块的结果类型是 String 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;&quot;&quot;\n\t\t文本块&quot;&quot;&quot;;</code></pre>\n</li>\n<li><p>文本块内部，可以自由地使用换行符和引号，而无需转义换行符。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;&quot;&quot;\n\t\t&quot;文本块&quot;是Java\n\t\t新增的功能&quot;&quot;&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n&quot;文本块&quot;是Java\n新增的功能</code></pre>\n\n<ul>\n<li>如果不想换行，可以在行末添加” \\ “</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;&quot;&quot;\n\t&quot;文本块&quot;是Java15\\\n\t新增的功能\\\n\t&quot;&quot;&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n&quot;文本块&quot;是Java15新增的功能</code></pre>\n\n<ul>\n<li>文本块的缩进逻辑是，检查所有非空行的最小缩进，然后整个文本块向左移动</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;&quot;&quot;\n\t\t测试\n\t\t\t&quot;文本块&quot;\n\t缩进&quot;&quot;&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n\t测试\n\t\t&quot;文本块&quot;\n缩进</code></pre>\n\n<ul>\n<li>Java15添加了新方法 formatted ，用来进行文本的变量替换。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String text &#x3D; &quot;&quot;&quot;\n\t\t测试输入参数：%s&quot;&quot;&quot;.formatted(&quot;text&quot;);\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n测试输入参数：text</code></pre>\n<h2 id=\"3-Records\"><a href=\"#3-Records\" class=\"headerlink\" title=\"3. Records\"></a>3. Records</h2><h3 id=\"1-简介-2\"><a href=\"#1-简介-2\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><ul>\n<li><p>Record 类型是 Java14 中引入的， Java16 中成为正式特性</p>\n</li>\n<li><p>Record 类是Java中的一种新型类，可以通过非常简洁的方式创建不可变数据对象，其目的是用作简单的数据载体</p>\n</li>\n<li><p>record中，get方法、构造函数、equals、hashCode、toString方法都是自动创建的。</p>\n</li>\n</ul>\n<h3 id=\"2-用法-2\"><a href=\"#2-用法-2\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><ul>\n<li>一个简单的示例：</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public record Person(String name, Integer age) &#123;\n&#125;</code></pre>\n\n<ul>\n<li>上面的record声明与下面的写法是等效的</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    private final String name;\n    private final Integer age;\n\n    public Person(String name, Integer age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public String name() &#123;\n        return name;\n    &#125;\n\n    public Integer age() &#123;\n        return age;\n    &#125;\n\n    public boolean equals...\n    public int hashCode...\n\n    public String toString() &#123;...&#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>record 类中，我们可以自定义构造函数，以实现对字段的的验证</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public record Person(String name, Integer age) &#123;\n    public Person(String name) &#123;\n        this(name, null);\n    &#125;\n    public Person(String name, Integer age) &#123;\n        Objects.requireNonNull(name);\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>record 类中可以添加静态变量和方法</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public record Person(String name, Integer age) &#123;\n\n    public static String ANONYMOUS_PERSON_NAME &#x3D; &quot;anonymous&quot;;\n\n    public static Person anonymous() &#123;\n        return new Person(ANONYMOUS_PERSON_NAME, null);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-与Lombok的比较\"><a href=\"#3-与Lombok的比较\" class=\"headerlink\" title=\"3. 与Lombok的比较\"></a>3. 与Lombok的比较</h3><ul>\n<li>两者都可以减少样板代码</li>\n<li>record 是Java的语言特性， Lombok 是第三方库</li>\n<li>record 适合创建小型不可变对象， Lombok 适用性更广<ul>\n<li>当数据模型中字段很多时，使用record将难以阅读和理解</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public record Person(String name,\n                     Integer age,\n                     String email,\n                     String address,\n                     String country,\n                     String phoneNumber\n) &#123;\n    public static void main(String[] args) &#123;\n        Person person &#x3D; new Person(&quot;张三&quot;, 30 , null, null, null,\n                &quot;19988887777&quot;);\n    &#125;\n&#125;</code></pre>\n<h4 id=\"Lombok-则提供了Builder设计模式，只需添加-Builder注解即可\"><a href=\"#Lombok-则提供了Builder设计模式，只需添加-Builder注解即可\" class=\"headerlink\" title=\"Lombok 则提供了Builder设计模式，只需添加@Builder注解即可\"></a>Lombok 则提供了Builder设计模式，只需添加@Builder注解即可</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Getter\n@Builder\npublic class Person &#123;\n    private String name;\n    private Integer age;\n    private String email;\n    private String address;\n    private String country;\n    private String phoneNumber;\n\n    public static void main(String[] args) &#123;\n        Person person &#x3D; Person.builder()\n                .name(&quot;张三&quot;)\n                .build();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"4-密封类和接口\"><a href=\"#4-密封类和接口\" class=\"headerlink\" title=\"4. 密封类和接口\"></a>4. 密封类和接口</h2><h3 id=\"1-简介-3\"><a href=\"#1-简介-3\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><ul>\n<li><p>密封类( Sealed Classes )在 Java15 中引入， Java17 中正式发布。</p>\n</li>\n<li><p>以前Java中继承的管理粒度比较粗，密封类可以实现对继承的细粒度控制。</p>\n</li>\n<li><p>密封类允许声明那些类型可以作为子类，对接口来说，就是声明哪些类型能实现它们</p>\n</li>\n</ul>\n<h3 id=\"2-用法-3\"><a href=\"#2-用法-3\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><ul>\n<li>密封类的声明方法：将 sealed 修饰符添加到声明中，并在 permits 子句中指定继承的类</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public sealed interface Living permits Person &#123;\n    default void eat() &#123;\n    &#125;\n&#125;\n\n@Getter\n@Setter\npublic sealed class Person implements Living permits Employee, Manager &#123;\n    private String name;\n    private Integer age;\n&#125;\n\n@Getter\n@Setter\npublic final class Employee extends Person&#123;\n&#125;\n\n@Getter\n@Setter\npublic non-sealed class Manager extends Person &#123;\n&#125;</code></pre>\n\n<ul>\n<li><p>密封类的字类或实现类，必须声明为 final 、 sealed 或 non-sealed</p>\n<ul>\n<li><p>final: 无法进一步扩展</p>\n</li>\n<li><p>sealed: 只能由其允许的子类扩展</p>\n</li>\n<li><p>non-sealed：可以被未知的子类扩展</p>\n</li>\n</ul>\n</li>\n<li><p>密封类的好处是其层次结构是有限且详尽的，尤其在类型判断时，可以更容易确定所有的类型信息</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (person instanceof Employee employee) &#123;\n    return employee.getEmployeeId();\n&#125; else if (person instanceof Manager manager) &#123;\n    return manager.getManagerId();\n&#125;</code></pre>\n\n<h2 id=\"5-instanceof-模式匹配\"><a href=\"#5-instanceof-模式匹配\" class=\"headerlink\" title=\"5.instanceof 模式匹配\"></a>5.instanceof 模式匹配</h2><h3 id=\"1-简介-4\"><a href=\"#1-简介-4\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h3><ul>\n<li><p>模式匹配功能在 Java14 中引入， Java16 中正式发布</p>\n</li>\n<li><p>模式匹配功能是对原有模式匹配的功能增强，引入新的绑定变量简化类型强转过程中的样板代码。</p>\n</li>\n</ul>\n<h3 id=\"2-使用方式\"><a href=\"#2-使用方式\" class=\"headerlink\" title=\"2. 使用方式\"></a>2. 使用方式</h3><ul>\n<li>原有的模式匹配使用方式</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (person instanceof Employee) &#123;\n\tEmployee employee &#x3D; (Employee) person;\n\treturn employee.getEmployeeId();\n&#125;\nelse if (person instanceof Manager) &#123;\n\tManager manager &#x3D; (Manager) person;\n\treturn manager.getManagerId();\n&#125;</code></pre>\n\n<ul>\n<li>新的模式匹配方式</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (person instanceof Employee employee) &#123;\n\treturn employee.getEmployeeId();\n&#125; else if (person instanceof Manager manager) &#123;\n\treturn manager.getManagerId();\n&#125;</code></pre>\n\n<h2 id=\"6-LTS模式的变化\"><a href=\"#6-LTS模式的变化\" class=\"headerlink\" title=\"6. LTS模式的变化\"></a>6. LTS模式的变化</h2><ul>\n<li><p>自 Java 10以来，采用了新的六个月功能发布模型，LTS版本 3 年发布一次，发布的LTS版本包括</p>\n</li>\n<li><p>Java SE 11（ 2018 年 9 月发布）和 Java SE 17（ 2021 年 9 月发布）</p>\n</li>\n<li><p>Java17之后，LTS版本发布时间变成 2 年。即下一个LTS版本为 Java21 ，将于 2023 年 9 月发布。</p>\n</li>\n<li><p>Java21将会带来 虚拟线程<a href=\"https://openjdk.org/jeps/436\">Virtual Threads</a> 技术，需要重点关注</p>\n</li>\n</ul>\n<h2 id=\"7-其他特性\"><a href=\"#7-其他特性\" class=\"headerlink\" title=\"7. 其他特性\"></a>7. 其他特性</h2><ul>\n<li><p>新的打包工具 jpackage ，可以将Java程序打包成特定平台的格式包</p>\n<ul>\n<li><p>Linux：deb和rpm</p>\n</li>\n<li><p>macOS：pkg和dmg</p>\n</li>\n<li><p>windows：msi和exe</p>\n</li>\n</ul>\n</li>\n<li><p>更有用的 NullPointerExceptions ，提供了更详细的异常信息</p>\n</li>\n<li><p>经历 Java11 到 Java14 四个版本的预览，ZGC在 Java15 中正式发布</p>\n</li>\n<li><p>可以在利用反射调用接口默认方法</p>\n</li>\n</ul>\n","text":"Java8-17 新特性（三）1. 新的switch表达式1. 简介 新的 switch 表达式在 Java12 中作为预览功能引入，在 Java14 中成为正式功能 2. 用法 原有的 switch 表达式写法 DayOfWeek dayOfWeek &#x3D; LocalD...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":9,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":10,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java8-17-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89\"><span class=\"toc-text\">Java8-17 新特性（三）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%96%B0%E7%9A%84switch%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">1. 新的switch表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1. 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">2. 用法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%96%87%E6%9C%AC%E5%9D%97\"><span class=\"toc-text\">2. 文本块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B-1\"><span class=\"toc-text\">1. 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%94%A8%E6%B3%95-1\"><span class=\"toc-text\">2. 用法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Records\"><span class=\"toc-text\">3. Records</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B-2\"><span class=\"toc-text\">1. 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%94%A8%E6%B3%95-2\"><span class=\"toc-text\">2. 用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%B8%8ELombok%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">3. 与Lombok的比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Lombok-%E5%88%99%E6%8F%90%E4%BE%9B%E4%BA%86Builder%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8F%AA%E9%9C%80%E6%B7%BB%E5%8A%A0-Builder%E6%B3%A8%E8%A7%A3%E5%8D%B3%E5%8F%AF\"><span class=\"toc-text\">Lombok 则提供了Builder设计模式，只需添加@Builder注解即可</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4. 密封类和接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B-3\"><span class=\"toc-text\">1. 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%94%A8%E6%B3%95-3\"><span class=\"toc-text\">2. 用法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">5.instanceof 模式匹配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B-4\"><span class=\"toc-text\">1. 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2. 使用方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-LTS%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">6. LTS模式的变化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">7. 其他特性</span></a></li></ol></li></ol>","author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/xiaohai-store","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2020"}}}},"mapped":true,"prev_post":{"title":"docker-compose 安装speedtest-x","uid":"1c07e8e18147453690b20ad48c124945","slug":"docker-compose-安装speedtest-x","date":"2023-03-28T08:20:38.000Z","updated":"2023-03-30T05:51:17.502Z","comments":true,"path":"api/articles/docker-compose-安装speedtest-x.json","keywords":null,"cover":"https://picsum.photos/432/285?random=1","text":"docker-compose 安装speedtest-xspeedtest-x是基于网页测速的原理，程序生成无用文件供测速者下载来计算真实下行带宽。它使用文件数据库来保存来自不同用户的测速结果，方便查看同地域与运营商的测速效果。 speedtest配置文件 #docker-com...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"docker","slug":"docker","count":4,"path":"api/categories/docker.json"}],"tags":[{"name":"docker","slug":"docker","count":4,"path":"api/tags/docker.json"}],"author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/xiaohai-store","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2020"}}}}},"next_post":{"title":"WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘","uid":"b04316b686c36577d18d894832d38043","slug":"WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘","date":"2023-03-26T02:40:52.000Z","updated":"2023-03-27T01:41:49.697Z","comments":true,"path":"api/articles/WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘.json","keywords":null,"cover":null,"text":"WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘 在目标盘创建文件夹 docker-desktop-data docker-desktop 停止docker-desktop和docker-desktop-data运行 wsl --s...","link":"","photos":[],"count_time":{"symbolsCount":829,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"小海","slug":"blog-author","avatar":"/avatar/avatar.jpg","link":"/","description":"用一点点代码,改变生活","socials":{"github":"https://github.com/xiaohai-store","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_27873145","juejin":"","customs":{"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/wch2020"}}}}}}