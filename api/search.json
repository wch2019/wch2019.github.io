[{"id":"0176ebc5803154a7154616b6c918b6d8","title":"TS 报错 Could not find a declaration file for module","content":"有的npm包使用原生js没问题，换ts后某些包会报“Could not find a declaration file for module”的错误。\n有以下两种方式解决\n1、下载 @type&#x2F;报错包（部分包开发者可能没有上传自己的.d.ts代码到npm分支，这时会报错说找不到这个包，别急看下一步）\n2、最直接简单有效的解决方法：项目src目录下新建shims-vue.d.ts文件\n&#x2F;&#x2F;declare声明宣告， 声明一个ambient module(即:没有内部实现的 module声明) \ndeclare module &#39;*.vue&#39; &#123;\n  import Vue from &#39;vue&#39;\n  export default Vue\n&#125;\n \ndeclare module &#39;XX&#39;\n&#x2F;&#x2F; xx即你包不能找到声明的包名\n\n\n唯一要注意的一点时，使用vscode第一次创建该文件后应该要重启才能看到效果，之后就是热生效啦，声明保存后报错立即就会消失。\nhttps://www.cnblogs.com/suihung/p/16786311.html\n","slug":"TS-报错-Could-not-find-a-declaration-file-for-module","date":"2023-04-28T09:38:44.000Z","categories_index":"ts","tags_index":"ts","author_index":"小海"},{"id":"aa88d56e526affb5a267e77d4e489f38","title":"mysql出现错误 utf8mb4_0900_ai_ci 或 utf8_0900_ai_ci","content":"在使用mysql工具或者使用第三方数据库管理工具，进行数据库导入运行SQL脚本的时候，出现这种 “utf8_0900_ai_ci” 错误 ，均是数据库版本从高版本导入到低版本导致的。解决方案有两种：\n\n使用一致的数据库版本\n\n打开sql脚本，把sql脚本中的所有  utf8mb4_0900_ai_ci  或者 utf8_0900_ai_ci  替换为utf8_general_ci，同时将utf8mb4替换为utf8\n\n\n修改保存之后在运行SQL脚本，就不在会出现错误了\n","slug":"mysql出现错误-utf8mb4-0900-ai-ci-或-utf8-0900-ai-ci","date":"2023-04-24T14:17:51.000Z","categories_index":"mysql","tags_index":"mysql","author_index":"小海"},{"id":"61fc98135e2353723c0c8a8a2e4c6cf6","title":"vite+vue3 使用svg icon","content":"vite+vue3 使用svg icon(包括element-plus icon)1、安装依赖npm i @element-plus&#x2F;icons-vue -S\nnpm i vite-plugin-svg-icons -D\n\n2、在vite.config.ts文件中import path from &#39;path&#39;;\nimport &#123; createSvgIconsPlugin &#125; from &#39;vite-plugin-svg-icons&#39;; &#x2F;&#x2F; 版本不同引入方式不同\nexport default defineConfig(&#123;\n  ...\n  plugins: [\n    ...\n    createSvgIconsPlugin(&#123;\n      &#x2F;&#x2F; 指定需要缓存的图标文件夹\n      iconDirs: [path.resolve(process.cwd(), &#39;src&#x2F;assets&#x2F;icons&#x2F;svg&#39;)],\n      &#x2F;&#x2F; 指定symbolId格式\n      symbolId: &#39;icon-[dir]-[name]&#39;\n    &#125;)\n  ]\n&#125;);\n\n且按照iconDirs中路径准备好svg文件\n\n3、创建引入全部element-plus文件，以及创建SvgIcon组件在components文件夹下创建如下文件\n\ncomponents&#x2F;SvgIcon&#x2F;svgicon.ts文件内容如下\n&#x2F;&#x2F; 注册所有 @element-plus&#x2F;icons-vue 图标\nimport * as ElementPlusIconsVue from &#39;@element-plus&#x2F;icons-vue&#39;;\nimport &#123; App &#125; from &#39;vue&#39;;\nexport default &#123;\n  install: (app: App&lt;Element&gt;) &#x3D;&gt; &#123;\n    for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123;\n      app.component(key, component);\n    &#125;\n  &#125;\n&#125;;\n\ncomponents&#x2F;SvgIcon&#x2F;index.vue文件内容如下\n&#x2F;&#x2F; 注册自定义图标\n&lt;template&gt;\n  &lt;svg :class&#x3D;&quot;svgClass&quot; aria-hidden&#x3D;&quot;true&quot;&gt;\n    &lt;use :xlink:href&#x3D;&quot;iconName&quot; :fill&#x3D;&quot;color&quot; &#x2F;&gt;\n  &lt;&#x2F;svg&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; computed &#125; from &#39;vue&#39;;\nconst props &#x3D; defineProps(&#123;\n  iconClass: &#123; &#x2F;&#x2F; 图标名称与assets&#x2F;icon&#x2F;svg下使用的文件名一致\n    type: String,\n    required: true\n  &#125;,\n  className: &#123; &#x2F;&#x2F; 给图标添加class\n    type: String,\n    default: &#39;&#39;\n  &#125;,\n  color: &#123; &#x2F;&#x2F; 设置图标颜色\n    type: String,\n    default: &#39;#333&#39;\n  &#125;\n&#125;);\nconst iconName &#x3D; computed(() &#x3D;&gt; &#123;\n  return &#96;#icon-$&#123;props.iconClass&#125;&#96;;\n&#125;);\nconst svgClass &#x3D; computed(() &#x3D;&gt; &#123;\n  if (props.className) &#123;\n    return &#96;svg-icon $&#123;props.className&#125;&#96;;\n  &#125;\n  return &#39;svg-icon&#39;;\n&#125;);\n&lt;&#x2F;script&gt;\n\n&lt;style scope lang&#x3D;&quot;scss&quot;&gt;\n.sub-el-icon,\n.nav-icon &#123;\n  display: inline-block;\n  font-size: 15px;\n  margin-right: 12px;\n  position: relative;\n&#125;\n\n.svg-icon &#123;\n  width: 1em;\n  height: 1em;\n  position: relative;\n  fill: currentColor;\n  vertical-align: -2px;\n&#125;\n&lt;&#x2F;style&gt;\n\n4、在main.ts中引入&#x2F;&#x2F; 注册所有图标\nimport &#39;virtual:svg-icons-register&#39;;  &#x2F;&#x2F; 引入注册脚本\nimport SvgIcon from &#39;@&#x2F;components&#x2F;SvgIcon&#x2F;index.vue&#39;;\nimport elementIcons from &#39;@&#x2F;components&#x2F;SvgIcon&#x2F;svgicon&#39;;\napp.component(&#39;SvgIcon&#39;, SvgIcon);\napp.use(elementIcons);\n\n5、使用方法&#x2F;&#x2F; 自定义的svg图标\n&lt;svg-icon icon-class&#x3D;&quot;lock&quot; class&#x3D;&quot;loack-icon&quot;&gt;&lt;&#x2F;svg-icon&gt;\n\n&#x2F;&#x2F; element-plus图标\n&lt;el-icon&gt;&lt;user-filled &#x2F;&gt;&lt;&#x2F;el-icon&gt;\n\n大功告成\n参考\n简书\n\n","slug":"vite-vue3-使用svg-icon","date":"2023-04-21T01:58:34.000Z","categories_index":"vue","tags_index":"vue","author_index":"小海"},{"id":"48378027e7fee1fc52d3894444f69110","title":"vue-quill-editor富文本编辑器","content":"Vue-Quill-Editor基于 Quill、适用于 Vue 的富文本编辑器，支持服务端渲染和单页应用。\n使用方法\n导入\n\n  npm install vue-quill-editor --save\n\n\n引入\n有两种挂载方式： 全局挂载 和 在组件中挂载，根据自己的项目需求选择\n\n\n\n挂载全局\nimport Vue from &#39;vue&#39;\nimport VueQuillEditor from &#39;vue-quill-editor&#39;\n \n&#x2F;&#x2F; require styles\nimport &#39;quill&#x2F;dist&#x2F;quill.core.css&#39;\nimport &#39;quill&#x2F;dist&#x2F;quill.snow.css&#39;\nimport &#39;quill&#x2F;dist&#x2F;quill.bubble.css&#39;\n \nVue.use(VueQuillEditor, &#x2F;* &#123; default global options &#125; *&#x2F;)\n\n挂载组件\n  &#x2F;&#x2F; require styles\n  import &#39;quill&#x2F;dist&#x2F;quill.core.css&#39;\n  import &#39;quill&#x2F;dist&#x2F;quill.snow.css&#39;\n  import &#39;quill&#x2F;dist&#x2F;quill.bubble.css&#39;\n  import &#123; quillEditor &#125; from &#39;vue-quill-editor&#39;\n  \n  export default &#123;\n    components: &#123;\n      quillEditor\n    &#125;\n  &#125;\n  \n\n3. 在页面上写组件\n\n   &#96;&#96;&#96;html\n   &lt;quill-editor\n    v-model&#x3D;&quot;content&quot;\n    ref&#x3D;&quot;myQuillEditor&quot;\n    :options&#x3D;&quot;editorOption&quot;\n    @blur&#x3D;&quot;onEditorBlur($event)&quot;\n    @focus&#x3D;&quot;onEditorFocus($event)&quot;\n    @change&#x3D;&quot;onEditorChange($event)&quot;\n    @ready&#x3D;&quot;onEditorReady($event)&quot;&gt;\n   &lt;&#x2F;quill-editor&gt;\n\n  &#x2F;&#x2F; 失去焦点事件\nonEditorBlur(quill) &#123;\n   console.log(&#39;editor blur!&#39;, quill)\n&#125;,\n &#x2F;&#x2F; 获得焦点事件\nonEditorFocus(quill) &#123;\n   console.log(&#39;editor focus!&#39;, quill)\n&#125;,\n &#x2F;&#x2F; 准备富文本编辑器\nonEditorReady(quill) &#123;\n   console.log(&#39;editor ready!&#39;, quill)\n&#125;,\n &#x2F;&#x2F; 内容改变事件\nonEditorChange(&#123; quill, html, text &#125;) &#123;\n   console.log(&#39;editor change!&#39;, quill, html, text)\n   this.content &#x3D; html\n&#125;,\n\n\n配置option\n&#x2F;&#x2F; 富文本编辑器配置\neditorOption: &#123;\n  modules: &#123;\n    toolbar: [\n      [&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;, &#39;strike&#39;], &#x2F;&#x2F; 加粗 斜体 下划线 删除线\n      [&#39;blockquote&#39;, &#39;code-block&#39;], &#x2F;&#x2F; 引用  代码块\n      [&#123; header: 1 &#125;, &#123; header: 2 &#125;], &#x2F;&#x2F; 1、2 级标题\n      [&#123; list: &#39;ordered&#39; &#125;, &#123; list: &#39;bullet&#39; &#125;], &#x2F;&#x2F; 有序、无序列表\n      [&#123; script: &#39;sub&#39; &#125;, &#123; script: &#39;super&#39; &#125;], &#x2F;&#x2F; 上标&#x2F;下标\n      [&#123; indent: &#39;-1&#39; &#125;, &#123; indent: &#39;+1&#39; &#125;], &#x2F;&#x2F; 缩进\n      [&#123; direction: &#39;rtl&#39; &#125;], &#x2F;&#x2F; 文本方向\n      [&#123; size: [&#39;12&#39;, &#39;14&#39;, &#39;16&#39;, &#39;18&#39;, &#39;20&#39;, &#39;22&#39;, &#39;24&#39;, &#39;28&#39;, &#39;32&#39;, &#39;36&#39;] &#125;], &#x2F;&#x2F; 字体大小\n      [&#123; header: [1, 2, 3, 4, 5, 6] &#125;], &#x2F;&#x2F; 标题\n      [&#123; color: [] &#125;, &#123; background: [] &#125;], &#x2F;&#x2F; 字体颜色、字体背景颜色\n       &#x2F;&#x2F; [&#123; font: [&#39;songti&#39;] &#125;], &#x2F;&#x2F; 字体种类\n      [&#123; align: [] &#125;], &#x2F;&#x2F; 对齐方式\n      [&#39;clean&#39;], &#x2F;&#x2F; 清除文本格式\n      [&#39;image&#39;, &#39;video&#39;] &#x2F;&#x2F; 链接、图片、视频\n    ]\n  &#125;,\n  placeholder: &#39;请输入正文&#39;\n&#125;,\n\n","slug":"vue-quill-editor富文本编辑器","date":"2023-04-19T01:45:16.000Z","categories_index":"vue","tags_index":"vue","author_index":"小海"},{"id":"cb1d68ce83a18012f138d3ac78fbff31","title":"类似github代码提交代码活跃图实现","content":"vue-calendar-heatmap在博客中实现类似github代码提交代码活跃图实现，基于 SVG 构建的轻量级日历热图 Vuejs 组件，灵感来自 github 的贡献日历图。在垂直模式下，工具提示由v-tooltip提供支持。\n安装npm install --save vue-calendar-heatmap\n\n使用特定组件：\n&lt;script&gt;\n  import &#39;vue-calendar-heatmap&#x2F;dist&#x2F;vue-calendar-heatmap.css&#39;\nimport &#123; CalendarHeatmap &#125; from &#39;vue-calendar-heatmap&#x2F;dist&#x2F;vue-calendar-heatmap.common&#39;\n\n  export default &#123;\n    components: &#123;\n      CalendarHeatmap\n    &#125;,\n    &#x2F;&#x2F; ...\n  &#125;\n&lt;&#x2F;script&gt;\n\n\n\n用法&lt;calendar-heatmap\n  :end-date&#x3D;&quot;new Date().toLocaleDateString()&quot;\n  :values&#x3D;&quot;timeValue&quot;\n  :locale&#x3D;&quot;locale&quot;\n  tooltip-unit&#x3D;&quot;文章数&quot;\n  :max&#x3D;&quot;6&quot;\n&#x2F;&gt;\n\nexport default &#123;\n  data() &#123;\n    return &#123;\n      locale: &#123;\n        months: [&#39;一月&#39;, &#39;二月&#39;, &#39;三月&#39;, &#39;四月&#39;, &#39;五月&#39;, &#39;六月&#39;, &#39;七月&#39;, &#39;八月&#39;, &#39;九月&#39;, &#39;十月&#39;, &#39;十一月&#39;, &#39;十二月&#39;],\n        days: [&#39;周日&#39;, &#39;周一&#39;, &#39;周二&#39;, &#39;周三&#39;, &#39;周四&#39;, &#39;周五&#39;, &#39;周六&#39;],\n        on: &#39;：&#39;,\n        less: &#39;少&#39;,\n        more: &#39;多&#39;\n      &#125;,\n      timeValue: [\n        &#123; date: &#39;2023-04-02&#39;, count: 1 &#125;,\n        &#123; date: &#39;2023-04-02&#39;, count: 2 &#125;,\n        &#123; date: &#39;2023-04-03&#39;, count: 3 &#125;,\n        &#123; date: &#39;2023-04-04&#39;, count: 4 &#125;,\n        &#123; date: &#39;2023-04-05&#39;, count: 5 &#125;,\n        &#123; date: &#39;2023-04-06&#39;, count: 6 &#125;\n      ]\n    &#125;\n  &#125;\n&#125;\n\n其他详细使用查看参考\n参考github\n","slug":"类似github代码提交代码活跃图实现","date":"2023-04-15T01:38:06.000Z","categories_index":"web","tags_index":"web","author_index":"小海"},{"id":"0effdaebab1d42c94cd222e67ffdef4d","title":"java对list集合进行分页","content":"1、计算页数：\nList&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();\n&#x2F;&#x2F;add...\n\n&#x2F;&#x2F;pageNo表示当前页[1-n]，pageSize表示每页大小\n\n\n&#x2F;&#x2F;方法一\nint total &#x3D; list.size();\nint pageSum &#x3D; (total -1) &#x2F; pageSize +1;\n\n&#x2F;&#x2F;方法二\nint total &#x3D; list.size();\nint pageSum &#x3D; total%pageSize&#x3D;&#x3D;0?total&#x2F;pageSize:total&#x2F;pageSize+1;\n\n&#x2F;&#x2F;方法三\nint total &#x3D; list.size();\nint pageSum&#x3D;(total+pageSize-1)&#x2F;pageSize;  \n\n\n2、java8 使用stream api进行分页：\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n\nList&lt;String&gt;list&#x3D;keys.stream().skip((pageNo-1)*pageSize).limit(pageSize).toList();\n\n\n3、普通方法分页：\n&#x2F;&#x2F;subList手动分页，page为第几页，rows为每页个数\npublic static List&lt;T&gt; subList(List&lt;T&gt; list, int page, int rows) throws Exception&#123;\n    List&lt;T&gt; listSort  &#x3D; new ArrayList&lt;&gt;();\n    int size&#x3D;list.size();\n    int pageStart&#x3D;page&#x3D;&#x3D;1?0:(page-1)*rows;&#x2F;&#x2F;截取的开始位置\n    int pageEnd&#x3D;size&lt;page*rows?size:page*rows;&#x2F;&#x2F;截取的结束位置\n    if(size&gt;pageStart)&#123;\n        listSort &#x3D;list.subList(pageStart, pageEnd);\n    &#125;\n    &#x2F;&#x2F;总页数\n    int totalPage&#x3D;list.size()&#x2F;rows;\n    return listSort;\n&#125;\n\n","slug":"java对list集合进行分页","date":"2023-04-12T12:07:17.000Z","categories_index":"java","tags_index":"java","author_index":"小海"},{"id":"7fb21e0fc382b694124b44093c516107","title":"Chrome书签手动同步方法","content":"Chrome书签手动同步方法保持登录状态\n架梯子\n在地址栏输入\nchrome:&#x2F;&#x2F;sync\n\n点击 Stop Sync (Keep Data)\nStop Sync (Keep Data)\n点击 Request Start\nRequest Start\n\n注意：在同步书签时，需要在两台设备上分别都执行一次以上操作，如果不行，重启chrome浏览器再重复以上操作\n参考   简书\n","slug":"Chrome书签手动同步方法","date":"2023-04-10T13:55:09.000Z","categories_index":"浏览器","tags_index":"浏览器","author_index":"小海"},{"id":"9e6155f6f360c999d321f53123f98bdc","title":"npm命令","content":"npm命令\n\n\n命令\n含义\n\n\n\nnpm -v\n版本 - 查看 npm 当前版本。\n\n\nnpm install\n安装 - 会根据项目中 package.json 文件自动下载项目所需的全部依赖。\n\n\nnpm install 包名 -D\n安装 - 安装的包只用于开发环境，不用于生产环境，会出现在\n\n\nnpm install 包名 -S\n安装 - 安装的包将会放在全局模块当中，所有的项目都可以使用。\n\n\nnpm uninstall 包名\n卸载 - 卸载指定包。\n\n\nnpm uninstall 包名 -g\n卸载 - 卸载指定全局模块包。\n\n\nnpm update 包名\n更新 - 更新指定包。\n\n\nnpm view 包名 versions\n查看版本 - 查看 包名 的所有版本号。\n\n\nnpm view 包名 version\n查看版本 - 查看 包名 的最新版本号。\n\n\nnpm info 包名\n查看信息 - 查看远程 npm 上指定包的所有版本信息。\n\n\nnpm list -g\t已安装列表\n- 查看全局已经安装过的 node 包。\n\n\nnpm list\n已安装列表 - 查看当前目录下已安装的 node 包。\n\n\nnpm root [包名]\n安装路径 - 查看当前包的安装路径。\n\n\nnpm root [包名] -g\n安装路径 - 查看全局的包的安装路径。\n\n\nnpm config set registry https://registry.npm.taobao.org\n修改镜像源 - 修改包下载源，此例修改为了淘宝镜像。\n\n\n","slug":"npm命令","date":"2023-04-10T01:35:19.000Z","categories_index":"vue","tags_index":"vue","author_index":"小海"},{"id":"d1b2ecb0ef898ec3b924540808846c88","title":"必应壁纸接口","content":"api : https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=zh-CN\n必应壁纸接口请求参数\n\n\n参数\nLianxia\n值\n\n\n\nformat\n非必需\n返回数据格式，不存在返回xml格式 js :返回 JSON 格式  XML : 返回XML 格式 一般是js\n\n\nidx\n非必需\n请求图片截止天数 0 今天 1 截止至昨天 -1 截止至明天\n\n\nn\n必需\n1-8 返回请求数量，最多一次获取8张()\n\n\nmkt\n非必需\n地区 如: zh-CN\n\n\n# 一次可以获取8张\n&#x2F;&#x2F; https:&#x2F;&#x2F;cn.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;js&amp;idx&#x3D;0&amp;n&#x3D;8&amp;mkt&#x3D;zh-CN\n\n&#123;\n  &quot;images&quot;: [\n    &#123;\n      &quot;startdate&quot;: &quot;20230405&quot;,\n      &quot;fullstartdate&quot;: &quot;202304051600&quot;,\n      &quot;enddate&quot;: &quot;20230406&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.ArizonaPinkMoon_ZH-CN5545607389_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.ArizonaPinkMoon_ZH-CN5545607389&quot;,\n      &quot;copyright&quot;: &quot;月亮升起，图森，亚利桑那州，美国 (© Tim Murphy&#x2F;Shutterstock)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E7%B2%89%E7%BA%A2%E8%89%B2%E6%9C%88%E4%BA%AE&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;亚利桑那州空中的粉月亮&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230405_ArizonaPinkMoon%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;ab591ebfad21386b6f36da52bc11421e&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230404&quot;,\n      &quot;fullstartdate&quot;: &quot;202304041600&quot;,\n      &quot;enddate&quot;: &quot;20230405&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.QingMing2023_ZH-CN6951199028_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.QingMing2023_ZH-CN6951199028&quot;,\n      &quot;copyright&quot;: &quot;杭州西湖水墨意境般的风景，浙江省，中国 (© zhangshuang&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E6%B8%85%E6%98%8E%E8%8A%82&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;水墨西湖&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230404_QingMing2023%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;fb3b90fb33dde5b3c99c9e2475635809&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230403&quot;,\n      &quot;fullstartdate&quot;: &quot;202304031600&quot;,\n      &quot;enddate&quot;: &quot;20230404&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.RomanBridge_ZH-CN4699931052_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.RomanBridge_ZH-CN4699931052&quot;,\n      &quot;copyright&quot;: &quot;科尔多瓦的古罗马桥，西班牙 (© Jeremy Woodhouse&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E7%A7%91%E5%B0%94%E5%A4%9A%E7%93%A6&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;这座古桥在哪呢？&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230403_RomanBridge%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;023e618c13f376da0139a6bec85dfdb5&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230402&quot;,\n      &quot;fullstartdate&quot;: &quot;202304021600&quot;,\n      &quot;enddate&quot;: &quot;20230403&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.HonaunauNP_ZH-CN4491662962_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.HonaunauNP_ZH-CN4491662962&quot;,\n      &quot;copyright&quot;: &quot;大岛上的霍瑙瑙国家历史公园，夏威夷 (© Westend61&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E9%9C%8D%E7%91%99%E7%91%99%E5%9B%BD%E5%AE%B6%E5%8E%86%E5%8F%B2%E5%85%AC%E5%9B%AD&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;追逐彩虹&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230402_HonaunauNP%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;1216eea4c984eb7488722eba133b68c4&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230401&quot;,\n      &quot;fullstartdate&quot;: &quot;202304011600&quot;,\n      &quot;enddate&quot;: &quot;20230402&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.JavaBromo_ZH-CN2744043733_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.JavaBromo_ZH-CN2744043733&quot;,\n      &quot;copyright&quot;: &quot;爪哇岛东部的婆罗摩火山，印度尼西亚 (© Bento Fotography&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E5%A9%86%E7%BD%97%E6%91%A9%E7%81%AB%E5%B1%B1&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;这座缥缈的山在哪里？&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230401_JavaBromo%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;285b1fc1eb78d0f282cacf8dc80588f2&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230331&quot;,\n      &quot;fullstartdate&quot;: &quot;202303311600&quot;,\n      &quot;enddate&quot;: &quot;20230401&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.FrogMonth_ZH-CN3874143397_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.FrogMonth_ZH-CN3874143397&quot;,\n      &quot;copyright&quot;: &quot;爪哇树蛙 (© kuritafsheen&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E7%88%AA%E5%93%87%E6%A0%91%E8%9B%99&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;一只青翠碧绿的蛙&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230331_FrogMonth%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;1893961139a4db2b6d3850df2975a9ac&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230330&quot;,\n      &quot;fullstartdate&quot;: &quot;202303301600&quot;,\n      &quot;enddate&quot;: &quot;20230331&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.SteyrRiver_ZH-CN3175702026_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.SteyrRiver_ZH-CN3175702026&quot;,\n      &quot;copyright&quot;: &quot;斯太尔河, 奥地利 (© guenterguni&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E6%96%AF%E5%A4%AA%E5%B0%94%E6%B2%B3+%E5%A5%A5%E5%9C%B0%E5%88%A9&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;大自然的蓝色奇观&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230330_SteyrRiver%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;557b605734213e7e5efaa6423bc47429&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;,\n    &#123;\n      &quot;startdate&quot;: &quot;20230329&quot;,\n      &quot;fullstartdate&quot;: &quot;202303291600&quot;,\n      &quot;enddate&quot;: &quot;20230330&quot;,\n      &quot;url&quot;: &quot;&#x2F;th?id&#x3D;OHR.PeacockFeathers_ZH-CN3403145691_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp&quot;,\n      &quot;urlbase&quot;: &quot;&#x2F;th?id&#x3D;OHR.PeacockFeathers_ZH-CN3403145691&quot;,\n      &quot;copyright&quot;: &quot;孔雀羽毛 (© sarayut Thaneerat&#x2F;Getty Images)&quot;,\n      &quot;copyrightlink&quot;: &quot;https:&#x2F;&#x2F;www.bing.com&#x2F;search?q&#x3D;%E5%AD%94%E9%9B%80%E7%BE%BD%E6%AF%9B&amp;form&#x3D;hpcapt&amp;mkt&#x3D;zh-cn&quot;,\n      &quot;title&quot;: &quot;华贵的色彩&quot;,\n      &quot;quiz&quot;: &quot;&#x2F;search?q&#x3D;Bing+homepage+quiz&amp;filters&#x3D;WQOskey:%22HPQuiz_20230329_PeacockFeathers%22&amp;FORM&#x3D;HPQUIZ&quot;,\n      &quot;wp&quot;: true,\n      &quot;hsh&quot;: &quot;715656440116ed2c7c9b6ee1414fe7f5&quot;,\n      &quot;drk&quot;: 1,\n      &quot;top&quot;: 1,\n      &quot;bot&quot;: 1,\n      &quot;hs&quot;: [\n        \n      ]\n    &#125;\n  ],\n  &quot;tooltips&quot;: &#123;\n    &quot;loading&quot;: &quot;正在加载...&quot;,\n    &quot;previous&quot;: &quot;上一个图像&quot;,\n    &quot;next&quot;: &quot;下一个图像&quot;,\n    &quot;walle&quot;: &quot;此图片不能下载用作壁纸。&quot;,\n    &quot;walls&quot;: &quot;下载今日美图。仅限用作桌面壁纸。&quot;\n  &#125;\n&#125;\n\n得到JSON 之后，可以知道 key &quot;url&quot; 对应的 value 就是地址\n在前面加上 https://cn.bing.com 就可以得到图片\n","slug":"必应壁纸接口","date":"2023-04-06T03:06:42.000Z","categories_index":"","tags_index":"","author_index":"小海"},{"id":"9e6ca69ab7b8015879f76631750d4660","title":"VMware共享文件挂载","content":"VMware共享文件挂载虚拟机设置-&gt;选项-&gt;共享文件夹-&gt;开启并添加一个共享文件夹\n安装vmware tools\n开启虚拟机\n\n\n\n\n\n\n\n\n\n提示：请确保您已登录客户机操作系统。在客户机中装载虚拟CD驱动器，启动终端，使用tar解压缩安装程序，然后执行vmware-install.pl安装vmwareTools\n\n挂载目录\n\nmount &#x2F;dev&#x2F;cdrom &#x2F;mnt \n\n\n拷贝\n\ncp &#x2F;mnt&#x2F;VMwareTools-xxxxxx.tar.gz &#x2F;home\n\n\n进入目录\n\ncd &#x2F;home\n\n\n取消挂载\n\numount &#x2F;mnt\n\n\n解压\n\ntar -zxvf VMwareTools-xxxxxx.tar.gz\n\n\n进入文件\n\ncd .&#x2F;vmware-tools-distrib  \n\n\n执行文件\n\n.&#x2F;vmware-install.pl\n\n\n\n\n\n\n\n\n\n\n注意，此处如果出现如下错误：-bash: .&#x2F;vmware-install.pl: &#x2F;usr&#x2F;bin&#x2F;perl: 坏的解释器: 没有那个文件或目录或vmware-install.pl: &#x2F;usr&#x2F;bin&#x2F;perl: bad interpreter: Permission denied swnek\n\n是因为未安装编译环境，请执行以下命令安装即可。\n\nyum -y install perl gcc gcc-c++ make cmake kernel kernel-headers kernel-devel net-tools\n\n\n重新执行安装文件进行安装，第一步输入yes以后一路回车即可\n\n.&#x2F;vmware-install.pl\n\n\n查看挂载文件名\n\nvmware-hgfsclient \n\n\n挂载文件\n\nmount -t ntfs-3g &#x2F;mount &#x2F;mnt&#x2F;hgfs\n\n出现提示\nmount: 未知的文件系统类型“vmhgfs”\n\n在终端输入下面的命令进行相关的安装\nyum install open-vm-tools-dkms\n\n\n安装成功后我们重新换另一种方法进行挂载共享文件夹\nvmhgfs-fuse .host:&#x2F;mount &#x2F;mnt&#x2F;hgfs\n\n最后可以看见将主机中的文件夹成功挂载上虚拟机当中\n","slug":"VMware共享文件挂载","date":"2023-03-31T07:04:51.000Z","categories_index":"VMware","tags_index":"VMware","author_index":"小海"},{"id":"b7f1061c94fc592a39aa69dd233c39b9","title":"img.shields.io README.md 制作徽标","content":"mg.shields.io RERADME.md 制作徽标快速开始官网：https://shields.io\n优点： 只需修改链接，不用静态制作。\n效果图：\n\n\n\n使用格式：方式一 ：HTML版&lt;!--使用破折号“-”分隔符,链接后面加上类型，支持的类型为SVG，PNG-&gt;\n&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;&lt;LABEL&gt;-&lt;MESSAGE&gt;-&lt;COLOR&gt;.svg&quot;&gt;\n\n ：需要的标签，例如springboot，jdk等，如有空格用%20代替 ：版本信息 ： 颜色 如蓝色blue等\n方式二：makedown![图片描述](图片链接) \n\n图片链接格式(同上)：https://img.shields.io/badge/&lt;LABEL&gt;-&lt;MESSAGE&gt;-&lt;COLOR&gt;.svg\n","slug":"img-shields-io-README-md-制作徽标","date":"2023-03-31T02:29:27.000Z","categories_index":"技能","tags_index":"技能","author_index":"小海"},{"id":"991063073d9e1c20d3fcd297440deaf2","title":"vue-json-viewer简单易用的json内容展示组件","content":"vue-json-viewer 简单易用的json内容展示组件npm 安装&#x2F;&#x2F; Vue2\n$ npm install vue-json-viewer@2 --save\n\n&#x2F;&#x2F; Vue3\n$ npm install vue-json-viewer@3 --save\n\n\n引入 JsonViewer\nimport JsonViewer from &#39;vue-json-viewer&#39;\nVue.use(JsonViewer)\n\n代码中使用&lt;json-viewer\n v-if&#x3D;&quot;form.jsonResult&quot;\n :value&#x3D;&quot;JSON.parse(form.jsonResult)&quot;\n :expand-depth&#x3D;&quot;1&quot;\n copyable\n boxed\n sort\n&gt;\n &lt;template slot&#x3D;&quot;copy&quot; slot-scope&#x3D;&quot;scope&quot;&gt;\n    &lt;el-button v-if&#x3D;&quot;!scope.copied&quot; type&#x3D;&quot;text&quot;&gt;复制&lt;&#x2F;el-button&gt;\n    &lt;el-button v-else type&#x3D;&quot;text&quot; disabled&gt;复制成功&lt;&#x2F;el-button&gt;\n &lt;&#x2F;template&gt;\n&lt;&#x2F;json-viewer&gt;\n\n选项\n\n\n属性\n描述\n默认值\n\n\n\nvalue\njson对象的值，可以使用v-model，支持响应式\n必填\n\n\nexpand-depth\n默认展开的层级\n1\n\n\ncopyable\n展示复制按钮，默认文案为：copy、copied!, 你可以设置一个对象&#123;copyText: &#39;copy&#39;, copiedText: &#39;copied&#39;&#125; 来自定义复制按钮文案\nfalse\n\n\nsort\n按照key排序展示\nfalse\n\n\nboxed\n为组件添加一个盒样式\nfalse\n\n\ntheme\n添加一个自定义的样式class用作主题\njv-light\n\n\nexpanded\n默认展开视图\nfalse\n\n\ntimeformat\n自定义时间格式函数\ntime &#x3D;&gt; time.toLocaleString()\n\n\npreview-mode\n不可折叠模式，默认全部展开\nfalse\n\n\nshow-array-index\n是否显示数组索引\ntrue\n\n\nshow-double-quotes\n展示key双引号\nfalse\n\n\n事件\n\n\n事件\n描述\n值\n\n\n\ncopied\n复制文本后的事件\n\n\n\nkeyclick\n点击key的事件\n\n\n\nSlots\n\n\n名称\n描述\nScope\n\n\n\ncopy\n自定义拷贝按钮\n&#123;copied: boolean&#125;\n\n\n快捷键\n\n\n名称\n描述\n\n\n\nalt + click\n展开当前节点下的所有节点\n\n\n参考\nnpmjs\ngithub中文\n\n","slug":"vue-json-viewer简单易用的json内容展示组件","date":"2023-03-31T01:09:54.000Z","categories_index":"web","tags_index":"vue,web","author_index":"小海"},{"id":"f8f3e6fc8bfd30a95b31c3b03dfa61df","title":"docker更新翻车现场(mysql)","content":"docker更新翻车现场(mysql)由于docker自动拉取最新mysql镜像导致mysql容器无法启动，当日志中出现如下代码：\nCannot boot server version 80031 on data directory built by version 80032. Downgrade is not supported\n\n翻译过来就是：\n无法在80032版本构建的数据目录上引导服务器80031版本。不支持降级\n\n那么这就是个悲伤的故事了,看完这个文章或许对你有帮助\n创建新容器，恢复数据创建新容器，使用旧的镜像，然后相关的环境变量和配置项都设置好，通过navicat连接保持畅通。\n通过ibd文件恢复数据1、首先创建一张表，表结构跟原表结构相同\n2、查询所有表名（为了批量操作）\nshow tables;\n\n3、删除表空间\nALTER TABLE users DISCARD TABLESPACE;\t\t\n\n可能会遇到\nCannot delete or update a parent row: a foreign key constraint fails\n\n原因：这个报错的原因是因为我们在执行sql的时候会进行外键约束检查，如果你想删除这个表的话，可以暂时将其关闭，删除完了之后在开启，如下：\nSET foreign_key_checks &#x3D; 0;  &#x2F;&#x2F; 关闭外键约束检查\n\nDROP TABLE  lms_course_quiz;  &#x2F;&#x2F; 删表\n\nSET foreign_key_checks &#x3D; 1; &#x2F;&#x2F; 再开启外键约束检查\n\n\n4、将待恢复的.ibd文件直接复制到现.ibd文件目录中\n5、恢复表空间\nALTER TABLE users IMPORT TABLESPACE;\n\n通过MYD MYI SDI数据库恢复\n\n\n文件\n说明\n\n\n\nXXX.sdi\n表结构文件\n\n\nXXX.MYD\n数据文件\n\n\nXXX.MYI\n索引文件\n\n\n\n前后对比，我们发现只有.sdi文件名不一样。先把旧表数据.MYD .MYI替换新表.MYD .MYI，然后将新表的.sdi给旧表重命名后替换！\n\n重启数据库，就可以看到数据已恢复！\n\n\n血与泪的教训1、使用docker容器的时候，一定要指定镜像image的版本号，不能使用latest，防止因为重启自动升级版本导致无法启动。\n2、数据库一定要做定时备份，平时用不到，用到了就能发挥大作用。即使是测试环境也要做，当然看情况。\n补充：Innodb与MyISAM存储文件的区别Innodb存储文件分为：.frm，.idb    .frm：存储表定义    .ibd：存储数据和索引MyISAM存储文件分为：.frm，.myd，.myi    .frm：存储表定义    .myd：存储数据    .myi：存储索引\n","slug":"docker更新翻车现场(mysql)","date":"2023-03-29T14:50:48.000Z","categories_index":"docker","tags_index":"docker,mysql","author_index":"小海"},{"id":"5fe8528ea44b3d1e48a9b1de61cf3137","title":"centos下docker无法正常下载新的镜像","content":"centos下docker无法正常下载新的镜像问题docker无法正常下载镜像，DockerHub上面明明有镜像缺显示not found。最终发现是因为docker版本太旧的问题。导致不支持了\n升级docker如果安装的时候使用如下命令，那么恭喜你，你中招了，老老实实升级docker吧\nyum install docker -y\n\n卸载旧版本旧版本的 Docker 名称为docker或docker-engine。在尝试安装新版本之前卸载任何此类旧版本以及相关的依赖项：\n$ sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\nyum如果报告没有安装这些软件包，那也没关系。\n当您卸载 Docker 时，存储在其中的图像、容器、卷和网络/var/lib/docker/不会自动删除。\n\n\n\n\n\n\n\n\n\n注意：更新后可能镜像版本没有指定，存在下载新的镜像,更新需谨慎！！！\n安装方法使用存储库安装在新主机上首次安装 Docker Engine 之前，您需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。\n设置存储库安装yum-utils包（提供yum-config-manager 实用程序）并设置存储库。\n$ sudo yum install -y yum-utils\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n\n安装 Docker 引擎\n安装 Docker Engine、containerd 和 Docker Compose：\n\n$ sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n如果提示接受 GPG 密钥，请验证指纹是否匹配 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35，如果匹配，则接受。\n\n启动docker\n\n$ sudo systemctl start docker\n\n\n此时就可以尝试一下是否可以正常下载镜像了\n\n参考\ndocker文档\n\n","slug":"centos下docker无法正常下载新的镜像","date":"2023-03-29T05:17:28.000Z","categories_index":"docker","tags_index":"docker","author_index":"小海"},{"id":"ff5e57e17f9e4c54e6268bc2967d2cf3","title":"nginx配置IP地址透传","content":"nginx配置IP地址透传问题我们在用nginx做反向代理的时候，通常会遇到一个问题：服务端解析请求时拿到的都是nginx代理服务器的ip，而不是真实的客户端ip\n解决这里介绍nginx在反向代理http服务时如何获取客户端真实ip\n\nipv4和ipv6的ip透传都只需要加这一行便可以实现：\n\n proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n\n详细配置\n\n location &#x2F; &#123;\n      proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;\n      proxy_set_header Host $host:$server_port;\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n&#125;\n\n","slug":"nginx配置IP地址透传","date":"2023-03-28T09:26:41.000Z","categories_index":"nginx","tags_index":"nginx","author_index":"小海"},{"id":"1c07e8e18147453690b20ad48c124945","title":"docker-compose 安装speedtest-x","content":"docker-compose 安装speedtest-xspeedtest-x是基于网页测速的原理，程序生成无用文件供测速者下载来计算真实下行带宽。它使用文件数据库来保存来自不同用户的测速结果，方便查看同地域与运营商的测速效果。\nspeedtest配置文件\n#docker-compse对应版本docker版本 \nversion: &#39;3&#39;\nservices:\n # speedtest配置\n  speedtest:\n    # speedtest镜像\n    image: adolfintel&#x2F;speedtest\n    # 设置自启\n    restart: always\n    # 容器名\n    container_name: speedtest\n    #设置容器的权限为root\n    privileged: true\n    # 端口绑定\n    ports:\n      - 8887:80\n\nspeedtest-x配置文件\n#docker-compse对应版本docker版本 \nversion: &#39;3&#39;\nservices:\n # speedtest配置\n  speedtest:\n    # speedtest镜像\n    image: badapple9&#x2F;speedtest-x:2022-07-27\n    # 设置自启\n    restart: always\n    # 容器名\n    container_name: speedtest\n    #设置容器的权限为root\n    privileged: true\n    # 端口绑定\n    ports:\n      - 8887:80\n    #环境变量\n    environment:\n      #最大可保存多少条测速记录\n      - MAX_LOG_COUNT&#x3D;100\n      #使用的 IP 运营商解析服务(ip.sb 或 ipinfo.io)\n      - IP_SERVICE&#x3D;ipinfo.io\n      #是否允许同一IP记录多条测速结果\n      - SAME_IP_MULTI_LOGS&#x3D;false\n\n\n\n参考\nspeedtest\n\nDockerHub\nGitHub\n\n\nspeedtest-x \n\nDockerHub\n\nGitHub\n\n\n\n\n","slug":"docker-compose-安装speedtest-x","date":"2023-03-28T08:20:38.000Z","categories_index":"docker","tags_index":"docker","author_index":"小海"},{"id":"4d03f17c3d855329753f1c2802880b5c","title":"Java8-17 新特性（三）","content":"Java8-17 新特性（三）1. 新的switch表达式1. 简介\n新的 switch 表达式在 Java12 中作为预览功能引入，在 Java14 中成为正式功能\n\n2. 用法\n原有的 switch 表达式写法\n\nDayOfWeek dayOfWeek &#x3D; LocalDate.now().getDayOfWeek();\nString typeOfDay;\nswitch (dayOfWeek) &#123;\n    case MONDAY:\n    case TUESDAY:\n    case WEDNESDAY:\n    case THURSDAY:\n    case FRIDAY:\n        typeOfDay &#x3D; &quot;Working Day&quot;;\n        break;\n    case SATURDAY:\n    case SUNDAY:\n        typeOfDay &#x3D; &quot;Day Off&quot;;\n&#125;\n\n\n新的 switch 表达式可以直接返回表达式的结果\n\nString typeOfDay &#x3D; switch (dayOfWeek) &#123;\n\tcase MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &quot;Working Day&quot;;\n\tcase SATURDAY, SUNDAY -&gt; &quot;Day Off&quot;;\n&#125;;\n\n新表达式支持yield字段\n\nString typeOfDay &#x3D; switch (dayOfWeek) &#123;\n    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &#123;\n        System.out.println(&quot;working day&quot;);\n        yield &quot;Working Day&quot;;\n    &#125;\n    case SATURDAY, SUNDAY -&gt; &#123;\n        System.out.println(&quot;day off&quot;);\n        yield &quot;Day Off&quot;;\n    &#125;\n&#125;;\n\n\n也可以不返回任何结果\n\nswitch (dayOfWeek) &#123;\n    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt;\n            System.out.println(&quot;Working Day&quot;);\n    case SATURDAY, SUNDAY -&gt; System.out.println(&quot;Day Off&quot;);\n&#125;\n\n\n\n2. 文本块1. 简介\n文本块( text blocks )在 Java13 中首次引入，在 Java15 中成为正式特性。\n\n2. 用法\n文本块以 “”” (三个双引号)开头，后跟一个换行符。文本块的结果类型是 String 。\nString text &#x3D; &quot;&quot;&quot;\n\t\t文本块&quot;&quot;&quot;;\n\n文本块内部，可以自由地使用换行符和引号，而无需转义换行符。\n\n\nString text &#x3D; &quot;&quot;&quot;\n\t\t&quot;文本块&quot;是Java\n\t\t新增的功能&quot;&quot;&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n&quot;文本块&quot;是Java\n新增的功能\n\n\n如果不想换行，可以在行末添加” \\ “\n\nString text &#x3D; &quot;&quot;&quot;\n\t&quot;文本块&quot;是Java15\\\n\t新增的功能\\\n\t&quot;&quot;&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n&quot;文本块&quot;是Java15新增的功能\n\n\n文本块的缩进逻辑是，检查所有非空行的最小缩进，然后整个文本块向左移动\n\nString text &#x3D; &quot;&quot;&quot;\n\t\t测试\n\t\t\t&quot;文本块&quot;\n\t缩进&quot;&quot;&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n\t测试\n\t\t&quot;文本块&quot;\n缩进\n\n\nJava15添加了新方法 formatted ，用来进行文本的变量替换。\n\nString text &#x3D; &quot;&quot;&quot;\n\t\t测试输入参数：%s&quot;&quot;&quot;.formatted(&quot;text&quot;);\nSystem.out.println(text);\n\n&gt;&gt;&gt;\n测试输入参数：text\n3. Records1. 简介\nRecord 类型是 Java14 中引入的， Java16 中成为正式特性\n\nRecord 类是Java中的一种新型类，可以通过非常简洁的方式创建不可变数据对象，其目的是用作简单的数据载体\n\nrecord中，get方法、构造函数、equals、hashCode、toString方法都是自动创建的。\n\n\n2. 用法\n一个简单的示例：\n\npublic record Person(String name, Integer age) &#123;\n&#125;\n\n\n上面的record声明与下面的写法是等效的\n\npublic class Person &#123;\n    private final String name;\n    private final Integer age;\n\n    public Person(String name, Integer age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public String name() &#123;\n        return name;\n    &#125;\n\n    public Integer age() &#123;\n        return age;\n    &#125;\n\n    public boolean equals...\n    public int hashCode...\n\n    public String toString() &#123;...&#125;\n&#125;\n\n\nrecord 类中，我们可以自定义构造函数，以实现对字段的的验证\npublic record Person(String name, Integer age) &#123;\n    public Person(String name) &#123;\n        this(name, null);\n    &#125;\n    public Person(String name, Integer age) &#123;\n        Objects.requireNonNull(name);\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n\nrecord 类中可以添加静态变量和方法\n\n\npublic record Person(String name, Integer age) &#123;\n\n    public static String ANONYMOUS_PERSON_NAME &#x3D; &quot;anonymous&quot;;\n\n    public static Person anonymous() &#123;\n        return new Person(ANONYMOUS_PERSON_NAME, null);\n    &#125;\n&#125;\n\n3. 与Lombok的比较\n两者都可以减少样板代码\nrecord 是Java的语言特性， Lombok 是第三方库\nrecord 适合创建小型不可变对象， Lombok 适用性更广\n当数据模型中字段很多时，使用record将难以阅读和理解\n\n\n\npublic record Person(String name,\n                     Integer age,\n                     String email,\n                     String address,\n                     String country,\n                     String phoneNumber\n) &#123;\n    public static void main(String[] args) &#123;\n        Person person &#x3D; new Person(&quot;张三&quot;, 30 , null, null, null,\n                &quot;19988887777&quot;);\n    &#125;\n&#125;\nLombok 则提供了Builder设计模式，只需添加@Builder注解即可@Getter\n@Builder\npublic class Person &#123;\n    private String name;\n    private Integer age;\n    private String email;\n    private String address;\n    private String country;\n    private String phoneNumber;\n\n    public static void main(String[] args) &#123;\n        Person person &#x3D; Person.builder()\n                .name(&quot;张三&quot;)\n                .build();\n    &#125;\n&#125;\n\n4. 密封类和接口1. 简介\n密封类( Sealed Classes )在 Java15 中引入， Java17 中正式发布。\n\n以前Java中继承的管理粒度比较粗，密封类可以实现对继承的细粒度控制。\n\n密封类允许声明那些类型可以作为子类，对接口来说，就是声明哪些类型能实现它们\n\n\n2. 用法\n密封类的声明方法：将 sealed 修饰符添加到声明中，并在 permits 子句中指定继承的类\n\npublic sealed interface Living permits Person &#123;\n    default void eat() &#123;\n    &#125;\n&#125;\n\n@Getter\n@Setter\npublic sealed class Person implements Living permits Employee, Manager &#123;\n    private String name;\n    private Integer age;\n&#125;\n\n@Getter\n@Setter\npublic final class Employee extends Person&#123;\n&#125;\n\n@Getter\n@Setter\npublic non-sealed class Manager extends Person &#123;\n&#125;\n\n\n密封类的字类或实现类，必须声明为 final 、 sealed 或 non-sealed\n\nfinal: 无法进一步扩展\n\nsealed: 只能由其允许的子类扩展\n\nnon-sealed：可以被未知的子类扩展\n\n\n\n密封类的好处是其层次结构是有限且详尽的，尤其在类型判断时，可以更容易确定所有的类型信息\n\n\nif (person instanceof Employee employee) &#123;\n    return employee.getEmployeeId();\n&#125; else if (person instanceof Manager manager) &#123;\n    return manager.getManagerId();\n&#125;\n\n5.instanceof 模式匹配1. 简介\n模式匹配功能在 Java14 中引入， Java16 中正式发布\n\n模式匹配功能是对原有模式匹配的功能增强，引入新的绑定变量简化类型强转过程中的样板代码。\n\n\n2. 使用方式\n原有的模式匹配使用方式\n\nif (person instanceof Employee) &#123;\n\tEmployee employee &#x3D; (Employee) person;\n\treturn employee.getEmployeeId();\n&#125;\nelse if (person instanceof Manager) &#123;\n\tManager manager &#x3D; (Manager) person;\n\treturn manager.getManagerId();\n&#125;\n\n\n新的模式匹配方式\n\nif (person instanceof Employee employee) &#123;\n\treturn employee.getEmployeeId();\n&#125; else if (person instanceof Manager manager) &#123;\n\treturn manager.getManagerId();\n&#125;\n\n6. LTS模式的变化\n自 Java 10以来，采用了新的六个月功能发布模型，LTS版本 3 年发布一次，发布的LTS版本包括\n\nJava SE 11（ 2018 年 9 月发布）和 Java SE 17（ 2021 年 9 月发布）\n\nJava17之后，LTS版本发布时间变成 2 年。即下一个LTS版本为 Java21 ，将于 2023 年 9 月发布。\n\nJava21将会带来 虚拟线程Virtual Threads 技术，需要重点关注\n\n\n7. 其他特性\n新的打包工具 jpackage ，可以将Java程序打包成特定平台的格式包\n\nLinux：deb和rpm\n\nmacOS：pkg和dmg\n\nwindows：msi和exe\n\n\n\n更有用的 NullPointerExceptions ，提供了更详细的异常信息\n\n经历 Java11 到 Java14 四个版本的预览，ZGC在 Java15 中正式发布\n\n可以在利用反射调用接口默认方法\n\n\n","slug":"Java8-17-新特性（三）","date":"2023-03-28T02:44:29.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"b04316b686c36577d18d894832d38043","title":"WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘","content":"WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘\n在目标盘创建文件夹\ndocker-desktop-data\n\ndocker-desktop\n\n\n停止docker-desktop和docker-desktop-data运行\nwsl --shutdown\n\n出docker-desktop和docker-desktop-data\nwsl --export docker-desktop-data D:\\\\docker-desktop-data\\docker-desktop-data.tar\n\nwsl --export docker-desktop D:\\\\docker-desktop\\docker-desktop.tar\n\n销docker-desktop和docker-desktop-data\nwsl --unregister docker-desktop-data\n\nwsl --unregister docker-desktop\n\n\n入docker-desktop和docker-desktop-data\nwsl --import docker-desktop-data D:\\\\docker-desktop-data D:\\\\docker-desktop-data\\docker-desktop-data.tar --version 2\n\nwsl --import docker-desktop D:\\\\docker-desktop D:\\\\docker-desktop\\docker-desktop.tar --version 2\n\n除压缩包\ndel D:\\docker-desktop-data\\docker-desktop-data.tar\n\ndel D:\\docker-desktop\\docker-desktop.tar\n新启动docker\nservice docker restart\n\n","slug":"WSL2迁移系统盘的docker-desktop和docker-desktop-data到其他盘","date":"2023-03-26T02:40:52.000Z","categories_index":"","tags_index":"","author_index":"小海"},{"id":"1f94f2baf38e1e6fca6620219a43c1fd","title":"切片上传文件时，后端拿到的文件名为blob问题","content":"切片上传文件时，后端拿到的文件名为blob问题说明的确是系统给我们的文件流自动命名为了blob，所以才导致了后端拿不到正确文件命。\n解决：formData的append可以接受三个参数，通过第三个参数我们可以手动设置filename参数：\nconst formData &#x3D; new FormData()\nformData.append(&#39;avatarFile&#39;, data, &#39;a.png&#39;)\n\n\n完美解决！\n","slug":"切片上传文件时，后端拿到的文件名为blob问题","date":"2023-03-24T09:56:22.000Z","categories_index":"web","tags_index":"Java,web","author_index":"小海"},{"id":"ecb8e5a10e45f278c6a4ce4dd6da0cfa","title":"vue 组件使用vuex中的mutations方法报错","content":"vue 组件使用vuex中的mutations方法报错报错：[vuex] unknown mutation type: SET_AVATAR\nvuex如果分为几个模块，方法是在某个模块中的话， 如果直接在组件中通过this.$store.commit(‘方法名’) 是获取不到的，必须要在前面加上模块名，如this.$store.commit(‘模块名&#x2F;方法名’) 才可以获取到。\n这个是我用到的\nthis.$store.commit(&#39;user&#x2F;SET_AVATAR&#39;, this.options.img)\n","slug":"vue 组件使用vuex中的mutations方法报错","date":"2023-03-24T09:45:16.000Z","categories_index":"web","tags_index":"web","author_index":"小海"},{"id":"dcf9a9ce359acc928646d0314f384068","title":"jdk8升级至jdk17新特性梳理","content":"jdk8升级至jdk17新特性梳理\n\n\n\n\n\n\n\n\n因为公司后续将采用jdk17进行开发，顾进行一个jdk17新特性的简单梳理\n升级jdk17的理由\n\n\n\n\n\n\n\n\n最简单的理由就是，springboot3.0放弃了jdk8，kafka4.0同样放弃了jdk8\n新特性梳理可以在接口中定义私有方法,主要为了jdk8的default方法public interface PricateMethodTest&#123;\n    default void defaultMethod()&#123;\n        privateMethod();\n    &#125;\n\n    private void privateMethod()&#123;\n\n    &#125;\n&#125;\n\n局部变量可以使用var来定义&#x2F;&#x2F; jdk8的写法\nString a1 &#x3D; &quot;111&quot;;\n&#x2F;&#x2F; jdk10之后的写法\nvar a2 &#x3D; &quot;222&quot;;\n\nHttp客户端链式操作public class Test&#123;\n    public static void main(String[] args)&#123;\n        var httpClient &#x3D; HttpClient.newBuilder()\n            .version(HttpClient.Version.HTTP_1_1)\n            .connectTimeout(Duration.ofSeconds(10))\n            .build();\n        var resuest &#x3D; HttpClient.newBuilder()\n            .GET()\n            .uri(URI.create(&quot;www.baidu.com&quot;))\n            .setHeader(&quot;User-Agent&quot;,&quot;Google&quot;)\n            .build();\n    &#125;\n&#125;\n\n提供了原生的websocket相关api(这块暂无测试)\n\n\n\n\n\n\n\n\n主要得益于SocketAPI 重构，Socket的底层实现优化，引入了NIO\n空指针问题\n\n\n\n\n\n\n\n\n在jdk14之前，异常捕获后抛出信息只有java.lang.NullPointerException测试代码\npublic static void main(String[] args) &#123;\n        try &#123;\n            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n            list.add(null);\n            System.out.println(list.get(0).longValue());\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n\n\n\n\n\n\n\n\n在jdk14之后，会显示具体的空指针对象，具体返回如下：\njava.lang.NullPointerException: Cannot invoke &quot;java.lang.Integer.longValue()&quot; because the return value of &quot;java.util.List.get(int)&quot; is null\n\nswitch改造\n\n\n\n\n\n\n\n\njdk17之前版本采用了break返回的方式\npublic static int testBreak(String mode)&#123;\n    int i &#x3D; 0;\n    switch(mode)&#123;\n        case &quot;a&quot;,&quot;b&quot;:\n            i &#x3D; 1;\n            break;\n        case &quot;c&quot;:\n            i &#x3D; 2;\n            break;\n        default:\n            i &#x3D; 3;\n            break;\n    &#125;\n    return i;\n&#125;\n\n\n\n\n\n\n\n\n\njdk14之后才用了yield\npublic static void testYield(String mode)&#123;\n    int result &#x3D; switch(mode)&#123;\n        case &quot;a&quot;,&quot;b&quot;:\n            yield 1; &#x2F;&#x2F; 使用yield提供返回值\n        case &quot;c&quot;:\n            yield 2; &#x2F;&#x2F; 使用yield提供返回值\n        default:\n            yield 3; &#x2F;&#x2F; 使用yield提供返回值\n    &#125;\n    return result;\n&#125;\n\n\n\n\n\n\n\n\n\n或者直接建图返回结果\npublic static void testYield(String mode)&#123;\n    int result &#x3D; switch(mode)&#123;\n        case &quot;a&quot;,&quot;b&quot; -&gt; 1;\n        case &quot;c&quot; -&gt; 2;\n        default -&gt; 3;\n    &#125;\n    return result;\n&#125;\n文本块的引入&#x2F;&#x2F; jdk1.8的写法\nString html &#x3D; &quot;&lt;html&gt;\\n&quot; +\n            &quot;   &lt;head&gt;\\n&quot; +\n            &quot;       &lt;title&gt;test&lt;&#x2F;title&gt;\\n&quot; +\n            &quot;   &lt;&#x2F;head&gt;\\n&quot; +\n            &quot;   &lt;body&gt;\\n&quot; +\n            &quot;       &lt;h1&gt;test&lt;&#x2F;h1&gt;\\n&quot; +\n            &quot;   &lt;&#x2F;body&gt;\\n&quot; +\n            &quot;  &lt;&#x2F;html&gt;\\n&quot;;\n&#x2F;&#x2F; jdk13的写法\nvar jdk15Html &#x3D; &quot;&quot;&quot;\n                &lt;html&gt;\n                    &lt;body&gt;\n                        &lt;p&gt;hello, world&lt;&#x2F;p&gt;\n                    &lt;&#x2F;body&gt;\n                &lt;&#x2F;html&gt;\n                &quot;&quot;&quot;;\n\ninstanceof的变化\n\n\n\n\n\n\n\n\njdk8是使用instanceof关键字判断类型之后，再强转，示例代码如下\n&#x2F;&#x2F; jdk8\nif (obj instanceof String) &#123;\n    String s &#x3D; (String) obj;\n    if (s.equals(&quot;1&quot;)) &#123;\n        System.out.println(&quot;1&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F; jdk16，则直接可在if中完成操作，str为申明的变量\nif (obj instanceof String str &amp;&amp; str.equals(&quot;1&quot;)) &#123;\n    System.out.println(&quot;1&quot;);\n&#125;\n申明对象时可用record关键字实现get set方法 public record User(long id,String name,int age)&#123;\n\n&#125;\n\n提供了VarHandle\n\n\n\n\n\n\n\n\njdk9之后提供的VarHandle时对Unsafe的一个优化，jdk9之前的Unsafe是不建议开发者直接使用的，因为Unsafe所操作的并不属于Java标准，会容易带来一些安全性的问题\n什么是VarHandle\n\n\n\n\n\n\n\n\nVarhandle是对变量或参数定义的变量系列的动态强类型引用，包括静态字段，非静态字段，数组元素或堆外数据结构的组件。 在各种访问模式下都支持访问这些变量，包括简单的读&#x2F;写访问，volatile 的读&#x2F;写访问以及 CAS (compare-and-set)访问。简单来说 Variable 就是对这些变量进行绑定，通过 Varhandle 直接对这些变量进行操作。\n举例  public class Demo &#123;\n    public int publicVar &#x3D; 1;\n    protected int protectedVar &#x3D; 2;\n    private int privateVar &#x3D; 3;\n    public int[] arrayData &#x3D; new int[]&#123;1, 2, 3&#125;;\n    @Override\n    public String toString() &#123;\n        return &quot;Demo&#123;&quot; +\n                &quot;publicVar&#x3D;&quot; + publicVar +\n                &quot;, protectedVar&#x3D;&quot; + protectedVar +\n                &quot;, privateVar&#x3D;&quot; + privateVar +\n                &quot;, arrayData&#x3D;&quot; + Arrays.toString(arrayData) +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n&#x2F;&#x2F; 访问private成员\nprivate static void privateDemo() throws NoSuchFieldException, IllegalAccessException &#123;\n    Demo instance &#x3D; new Demo();\n    VarHandle varHandle &#x3D; MethodHandles.privateLookupIn(Demo.class, MethodHandles.lookup())\n            .findVarHandle(Demo.class, &quot;privateVar&quot;, int.class);\n    varHandle.set(instance, 33);\n    System.out.println(instance);\n&#125;\n\n\n\n\n\n\n\n\n\n输出：Demo{publicVar&#x3D;1, protectedVar&#x3D;2, privateVar&#x3D;33, arrayData&#x3D;[1, 2, 3]}\n&#x2F;&#x2F; 访问 protected 成员\nprivate static void protectedDemo() throws NoSuchFieldException, IllegalAccessException &#123;\n    Demo instance &#x3D; new Demo();\n\n      VarHandle varHandle &#x3D; MethodHandles.privateLookupIn(Demo.class,MethodHandles.lookup())\n              .findVarHandle(Demo.class, &quot;protectedVar&quot;, int.class);\n\n    VarHandle varHandle &#x3D; MethodHandles.lookup()\n            .in(Demo.class)\n            .findVarHandle(Demo.class, &quot;protectedVar&quot;, int.class);\n    varHandle.set(instance, 22);\n    System.out.println(instance);\n&#125;\n\n\n\n\n\n\n\n\n\n输出：Demo{publicVar&#x3D;1, protectedVar&#x3D;22, privateVar&#x3D;3, arrayData&#x3D;[1, 2, 3]}\n&#x2F;&#x2F; 访问public成员\nprivate static void publicDemo() throws NoSuchFieldException, IllegalAccessException &#123;\n     Demo instance &#x3D; new Demo();\n     VarHandle varHandle &#x3D; MethodHandles.lookup()\n             .in(Demo.class)\n             .findVarHandle(Demo.class, &quot;publicVar&quot;, int.class);\n     varHandle.set(instance, 11);\n     System.out.println(instance);\n &#125;\n\n\n\n\n\n\n\n\n\n输出：Demo{publicVar&#x3D;11, protectedVar&#x3D;2, privateVar&#x3D;3, arrayData&#x3D;[1, 2, 3]}\n&#x2F;&#x2F; 访问数组\nprivate static void arrayDemo() throws NoSuchFieldException, IllegalAccessException &#123;\n    Demo instance &#x3D; new Demo();\n    VarHandle arrayVarHandle &#x3D; MethodHandles.arrayElementVarHandle(int[].class);\n    arrayVarHandle.compareAndSet(instance.arrayData, 0, 1, 11);\n    arrayVarHandle.compareAndSet(instance.arrayData, 1, 2, 22);\n    arrayVarHandle.compareAndSet(instance.arrayData, 2, 3, 33);\n    System.out.println(instance);\n&#125;\n\n\n\n\n\n\n\n\n\n输出：Demo{publicVar&#x3D;1, protectedVar&#x3D;2, privateVar&#x3D;3, arrayData&#x3D;[11, 22, 33]}\nVarhandle方法汇总\nMethodHandles.privateLookupIn(class, MethodHandles.lookup())获取访问私有变量的Lookup\nMethodHandles.lookup() 获取访问protected、public的Lookup\nfindVarHandle：用于创建对象中非静态字段的VarHandle。接收参数有三个，第一个为接收者的class对象，第二个是字段名称，第三个是字段类型。\nfindStaticVarHandle：用于创建对象中静态字段的VarHandle，接收参数与findVarHandle一致。\nunreflectVarHandle：通过反射字段Field创建VarHandle。\nMethodHandles.arrayElementVarHandle(int[].class) 获取管理数组的 Varhandle\n\n内存屏障VarHandle 除了支持各种访问模式下访问变量之外，还提供了一套内存屏障方法，目的是为了给内存排序提供更细粒度的控制。主要如下几个方法：\npublic static void fullFence() &#123;\n    UNSAFE.fullFence();\n&#125;\npublic static void acquireFence() &#123;\n    UNSAFE.loadFence();\n&#125;\npublic static void releaseFence() &#123;\n    UNSAFE.storeFence();\n&#125;\npublic static void loadLoadFence() &#123;\n    UNSAFE.loadLoadFence();\n&#125;\npublic static void storeStoreFence() &#123;\n    UNSAFE.storeStoreFence();\n&#125;\n\n小结\n\n\n\n\n\n\n\n\n在 java9 之后，对一些变量的并发操作时，可以考虑用 java.lang.invoke.VarHandle 来处理，而不是通过 Unsafe 类来处理，毕竟 Unsafe 不太适合直接使用。\nSealed Classes（封闭类）\n密封Sealed表示的概念是可以扩展一个类，但只能通过已知的子类型列表进行扩展，而不能通过其他任何扩展。\n其他语言可能对功能的看法有所不同，在Java中，应将其视为代表几乎最终类的功能。\nJava 16开始，允许使用 sealed 修饰class，并通过permits明确写出能够从该class继承的子类名称。&#x2F;&#x2F; 测试代码\npublic sealed class Car permits MiniCar, SmallCar, Bigcar&#123;\n    ...\n&#125;\n&#x2F;&#x2F; 以下代码可以正常运行\npublic final class MiniCar extends Car &#123;...&#125;\n&#x2F;&#x2F; 以下代码会报错\npublic final class Train extends Car &#123;...&#125;\n\n其他新特性\n\n\n\n\n\n\n\n\n其他新特性有待于各位小伙伴努力尝试\n","slug":"jdk8升级至jdk17新特性梳理","date":"2023-03-24T08:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"736ffb69a5e54f493abeeebf83cab52f","title":"vue-cropper一个优雅的图片裁剪插件","content":"vue-cropper一个优雅的图片裁剪插件一、安装使用1.npm 安装npm install vue-cropper\n\n2. 引入 Vue CropperVue2 组件内引入\nimport &#123; VueCropper &#125;  from &#39;vue-cropper&#39; \ncomponents: &#123;\n  VueCropper\n&#125;\n\nVue2 全局引入\nimport VueCropper from &#39;vue-cropper&#39;\nVue.use(VueCropper)\n\n3. 代码中使用&lt;VueCropper\n  ref&#x3D;&quot;cropper&quot;\n  :img&#x3D;&quot;options.img&quot;\n  :info&#x3D;&quot;options.info&quot;\n  :output-size&#x3D;&quot;options.outputSize&quot;\n  :output-type&#x3D;&quot;options.outputType&quot;\n  :auto-crop&#x3D;&quot;options.autoCrop&quot;\n  :auto-crop-width&#x3D;&quot;options.autoCropWidth&quot;\n  :auto-crop-height&#x3D;&quot;options.autoCropHeight&quot;\n  :fixed-box&#x3D;&quot;options.fixedBox&quot;\n  @real-time&#x3D;&quot;realTime&quot;\n&#x2F;&gt;\n\ndata() &#123;\n  return &#123;\n    options: &#123;\n       img: &#39;&#39;, &#x2F;&#x2F; 裁剪图片的地址\n       info: true, &#x2F;&#x2F; 裁剪框的大小信息\n       outputSize: 1, &#x2F;&#x2F; 裁剪生成图片的质量 0.1 - 1\n       outputType: &#39;png&#39;, &#x2F;&#x2F;\t裁剪生成图片的格式 jpeg || png || webp\n       autoCrop: true, &#x2F;&#x2F; 是否默认生成截图框\n       autoCropWidth: 200, &#x2F;&#x2F; 默认生成截图框宽度\n       autoCropHeight: 200, &#x2F;&#x2F; 默认生成截图框高度\n       fixedBox: true &#x2F;&#x2F; 固定截图框大小 不允许改变\n     &#125;\n  &#125;\n&#125;\n\n注：下划线和驼峰可能出现问题，用@realTime死活不行，改为@real-time就好用了，仅仅是为了记录这个问题写的，其他具体使用网上一大堆，可自行搜索\n参考\n演示Demo    \nnpmjs\ngithub\n\n","slug":"vue-cropper一个优雅的图片裁剪插件","date":"2023-03-24T08:29:56.000Z","categories_index":"web","tags_index":"web","author_index":"小海"},{"id":"b9e36f1b31fdb7446c5124e8f6e853e3","title":"mybatis实体类生成数据库","content":"mybatis实体类生成数据库为什么要用？因为数据库忘记备份，时间久了数据库没了，所以研究了一下这个东西，感谢大佬开发的反向生成，详细连接地址在文末\nJDKjdk版本1.7+\nACTable依赖&lt;dependency&gt;\n    &lt;groupId&gt;com.gitee.sunchenbin.mybatis.actable&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-enhance-actable&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.5.0.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nSpringBoot配置方式actable:\n  table:\n    # 可以设置为create（纯创建）、add（添加新的不删除内容）、update（更新内容，推荐用）、none（啥都不干）\n    auto: create\n  model:\n    # 用于创建数据表的待扫描目录，该目录下的类如果有@Table注解，就会进行扫描\n    #你的实体类放的包\n    pack: com.xiaohai.create.entity\n  database:\n    #目前仅支持mysql\n    type: mysql\n\nmybatis:\n  mapperLocations: classpath*:com&#x2F;gitee&#x2F;sunchenbin&#x2F;mybatis&#x2F;actable&#x2F;mapping&#x2F;*&#x2F;*xml\n\n\n\n配置解析：\n\n\n\n配置信息\n可选值值信息\n描述\n\n\n\nactable.table.auto\nnone\n系统不做任何处理。\n\n\ncreate\n系统启动后，会先将所有的表删除掉，然后根据model中配置的结构重新建表，该操作会破坏原有数据。\n\n\n\nupdate\n系统启动后，会自动判断哪些表是新建的，哪些字段要修改类型等，哪些字段要删除，哪些字段要新增，该操作不会破坏原有数据。\n\n\n\nadd\n系统启动后，只做新增，比如新增表&#x2F;新增字段&#x2F;新增索引&#x2F;新增唯一约束的功能，而不会去做修改和删除的操作 (只在版本1.0.9.RELEASE及以上支持)。\n\n\n\nactable.model.pack\n-\n您的model包路径，多个路径可以用分号或者逗号隔开，会递归这个目录下的全部目录中的java对象，支持类似com.bz.**.entity\n\n\nactable.database.type\nmysql\n这个是用来区别数据库的，预计会支持这四种数据库mysql&#x2F;oracle&#x2F;sqlserver&#x2F;postgresql，但目前仅支持mysql\n\n\nspringboot2.0+启动类需要做如下配置(必备)1.@ComponentScan配置，路径”com.gitee.sunchenbin.mybatis.actable.manager.*”\n2.@MapperScan配置，路径”com.gitee.sunchenbin.mybatis.actable.dao.*”\n@SpringBootApplication\n@MapperScan(&quot;com.gitee.sunchenbin.mybatis.actable.dao.*&quot;)\n@ComponentScan(basePackages &#x3D; &#123;&quot;com.gitee.sunchenbin.mybatis.actable.manager.*&quot;&#125;)\npublic class CreateTableApplication &#123;\n\n    public static void main(String[] args) &#123;\n       SpringApplication.run(CreateTableApplication.class, args);\n    &#125;\n\n&#125;\n多种定义方式第一种定义方式，使用@Table和@Column方式定义Data\n@Table(name &#x3D; &quot;test&quot;)\npublic class Test extends BaseModel &#123;\n\n\t@Column(name &#x3D; &quot;id&quot;,type &#x3D; MySqlTypeConstant.INT,length &#x3D; 11,isKey &#x3D; true,isAutoIncrement &#x3D; true)\n\tprivate Integer\tid;\n\n\t@Column(name &#x3D; &quot;name&quot;,type &#x3D; MySqlTypeConstant.VARCHAR, length &#x3D; 45, defaultValue &#x3D; &quot;hello&quot;)\n\tprivate String\tname;\n\n\t@Column(name &#x3D; &quot;type&quot;,type &#x3D; MySqlTypeConstant.VARCHAR,length &#x3D; 45)\n\tprivate String\ttype;\n\n\t@Column(name &#x3D; &quot;description&quot;,type &#x3D; MySqlTypeConstant.TEXT)\n\tprivate String\tdescription;\n\n\t@Column(name &#x3D; &quot;create_time&quot;,type &#x3D; MySqlTypeConstant.DATETIME)\n\tprivate Date\tcreate_time;\n\n\t@Column(name &#x3D; &quot;update_time&quot;,type &#x3D; MySqlTypeConstant.DATETIME)\n\tprivate Date\tupdate_time;\n\n\t@Column(name &#x3D; &quot;number&quot;,type &#x3D; MySqlTypeConstant.BIGINT,length &#x3D; 5)\n\tprivate Long\tnumber;\n\n\t@Column(name &#x3D; &quot;lifecycle&quot;,type &#x3D; MySqlTypeConstant.CHAR,length &#x3D; 1)\n\tprivate String\tlifecycle;\n\n\t@Column(name &#x3D; &quot;dekes&quot;,type &#x3D; MySqlTypeConstant.DOUBLE,length &#x3D; 5,decimalLength &#x3D; 2)\n\tprivate Double\tdekes;\n&#125;\n\n\n\n第二种定义方式，使用@Table和@Column定义字段，具体内容用具体注解定义@Data\n@Table(name &#x3D; &quot;test1&quot;)\npublic class Test1 extends BaseModel &#123;\n\n    @Id\n    @IsAutoIncrement\n    @Column\n    private Integer id;\n\n    @Column\n    private Double price;\n\n    @Column\n    @ColumnType(value &#x3D; MySqlTypeConstant.VARCHAR, length &#x3D; 455)\n    private String name;\n\n    @Column\n    private Date time;\n\n&#125;\n\n第三种定义方式，懒人定义，按照驼峰规则转换 ,不需要对每个字段设置@Column@Data\n@Table(isSimple &#x3D; true)\npublic class TestOne  &#123;\n\n   @IsKey\n   @IsAutoIncrement\n   private Integer  id;\n\n   private String name;\n\n   private String type;\n&#125;\n\n参考\nACTable-gitee            \nACTable开源框架文档\ndemo\n\n","slug":"mybatis实体类生成数据库","date":"2023-03-21T03:16:18.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"b5984abe1cd42992458002641ebaf9e8","title":"vue 图片预览组件 v-viewer","content":"vue 图片预览组件 v-viewer安装依赖npm install v-viewer --save\n在main.js添加import Viewer from &#39;v-viewer&#39;\nimport &#39;viewerjs&#x2F;dist&#x2F;viewer.css&#39;\nVue.use(Viewer)\n使用引入v-viewer及必需的css样式，并使用Vue.use()注册插件，之后即可使用。\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;!-- directive --&gt;\n    &lt;div class&#x3D;&quot;images&quot; v-viewer&gt;\n      &lt;img v-for&#x3D;&quot;src in images&quot; :key&#x3D;&quot;src&quot; :src&#x3D;&quot;src&quot;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;!-- component --&gt;\n    &lt;viewer :images&#x3D;&quot;images&quot;&gt;\n      &lt;img v-for&#x3D;&quot;src in images&quot; :key&#x3D;&quot;src&quot; :src&#x3D;&quot;src&quot;&gt;\n    &lt;&#x2F;viewer&gt;\n    &lt;!-- api --&gt;\n    &lt;button type&#x3D;&quot;button&quot; @click&#x3D;&quot;show&quot;&gt;Click to show&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import &#39;viewerjs&#x2F;dist&#x2F;viewer.css&#39;\n  import VueViewer from &#39;v-viewer&#39;\n  import Vue from &#39;vue&#39;\n  Vue.use(VueViewer)\n  export default &#123;\n    data() &#123;\n      return &#123;\n        images: [\n          &quot;https:&#x2F;&#x2F;picsum.photos&#x2F;200&#x2F;200&quot;,\n          &quot;https:&#x2F;&#x2F;picsum.photos&#x2F;300&#x2F;200&quot;,\n          &quot;https:&#x2F;&#x2F;picsum.photos&#x2F;250&#x2F;200&quot;\n        ]\n      &#125;;\n    &#125;,\n    methods: &#123;\n      show() &#123;\n        this.$viewerApi(&#123;\n          images: this.images,\n        &#125;)\n      &#125;,\n    &#125;,\n  &#125;\n&lt;&#x2F;script&gt;\n\n以api形式使用api形式只能使用modal模式。\n你可以直接执行函数: this.$viewerApi({options: {}, images: []}) 来展现画廊， 而不需要自己来渲染这些img元素.\n函数会返回对应的viewer实例.\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;button&quot; @click&#x3D;&quot;previewURL&quot;&gt;URL Array&lt;&#x2F;button&gt;\n    &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;button&quot; @click&#x3D;&quot;previewImgObject&quot;&gt;Img-Object Array&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  export default &#123;\n    data() &#123;\n      sourceImageURLs: [\n        &#39;https:&#x2F;&#x2F;picsum.photos&#x2F;200&#x2F;200?random&#x3D;1&#39;,\n        &#39;https:&#x2F;&#x2F;picsum.photos&#x2F;200&#x2F;200?random&#x3D;2&#39;,\n      ],\n      sourceImageObjects: [\n        &#123;\n          &#39;src&#39;:&#39;https:&#x2F;&#x2F;picsum.photos&#x2F;200&#x2F;200?random&#x3D;3&#39;,\n          &#39;data-source&#39;:&#39;https:&#x2F;&#x2F;picsum.photos&#x2F;800&#x2F;800?random&#x3D;3&#39;\n        &#125;,\n        &#123;\n          &#39;src&#39;:&#39;https:&#x2F;&#x2F;picsum.photos&#x2F;200&#x2F;200?random&#x3D;4&#39;,\n          &#39;data-source&#39;:&#39;https:&#x2F;&#x2F;picsum.photos&#x2F;800&#x2F;800?random&#x3D;4&#39;\n        &#125;\n      ]\n    &#125;,\n    methods: &#123;\n      previewURL () &#123;\n          &#x2F;&#x2F; 如果使用&#96;app.use&#96;进行全局安装, 你就可以像这样直接调用&#96;this.$viewerApi&#96;\n        const $viewer &#x3D; this.$viewerApi(&#123;\n          images: this.sourceImageURLs\n        &#125;)\n      &#125;,\n      previewImgObject () &#123;\n          &#x2F;&#x2F; 或者你可以单独引入api然后执行它\n        const $viewer &#x3D; viewerApi(&#123;\n          options: &#123;\n            toolbar: true,\n            url: &#39;data-source&#39;,\n            initialViewIndex: 1\n          &#125;,\n          images: this.sourceImageObjects\n        &#125;)\n      &#125;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n参考\n展示页            \n中文文档\ngithub\n\n","slug":"vue-图片预览组件-v-viewer","date":"2023-03-20T05:58:25.000Z","categories_index":"web","tags_index":"web","author_index":"小海"},{"id":"903c2b49181ed740deb9eac359f116c3","title":"Java File类","content":"Java中，File类是用于表示文件或目录的类，它提供了一些常用的属性和方法来操作文件或目录。以下是File类中常用的属性：\n\n文件或目录的名称：可以通过 File.getName() 方法获取。\n\n文件或目录的路径：可以通过 File.getPath() 方法获取。\n\n文件或目录的绝对路径：可以通过 File.getAbsolutePath() 方法获取。\n\n文件或目录是否存在：可以通过 File.exists() 方法判断。\n\n是否为目录：可以通过 File.isDirectory() 方法判断。\n\n是否为文件：可以通过 File.isFile() 方法判断。\n\n文件或目录的大小：可以通过 File.length() 方法获取。\n\n文件或目录的最后修改时间：可以通过 File.lastModified() 方法获取，返回值为毫秒数。\n\n\n这些属性可以帮助我们更好地了解文件或目录的信息，从而进行相应的操作。例如，我们可以通过判断文件或目录是否存在来确保程序安全性；通过获取文件或目录的大小来判断是否需要进行压缩或解压缩等操作；通过获取文件或目录的最后修改时间来判断文件是否需要更新等。\n","slug":"Java File类","date":"2023-03-18T01:30:47.000Z","categories_index":"","tags_index":"","author_index":"小海"},{"id":"fc8441281cafc01b53d6231870878c78","title":"SpringBoot循环依赖问题","content":"SpringBoot 循环依赖问题当你遇到这种情况时，就是循环依赖问题\nDescription:\n\nThe dependencies of some of the beans in the application context form a cycle:\n\n   configController defined in file [E:\\project\\gitee\\xiaohai-blog\\xiaohai-system\\target\\classes\\com\\xiaohai\\system\\controller\\ConfigController.class]\n┌─────┐\n|  configServiceImpl defined in file [E:\\project\\gitee\\xiaohai-blog\\xiaohai-system\\target\\classes\\com\\xiaohai\\system\\service\\impl\\ConfigServiceImpl.class]\n↑     ↓\n|  emailServiceImpl defined in file [E:\\project\\gitee\\xiaohai-blog\\xiaohai-system\\target\\classes\\com\\xiaohai\\system\\service\\impl\\EmailServiceImpl.class]\n└─────┘\n\nJava中的循环依赖问题指的是两个或多个类之间相互依赖，形成了一个环路，导致编译器无法确定某个类的具体实现。例如，类A依赖于类B，而类B又依赖于类A，这样就形成了一个循环依赖。这种问题通常会导致编译错误或运行时错误，因此需要避免出现循环依赖。以下是几种解决循环依赖问题的方法：\n\n重构代码：将相互依赖的类进行合理的划分和重构，消除循环依赖。\n\n使用接口：将相互依赖的类抽象成接口，然后再进行依赖注入，这样可以避免循环依赖。\n\n使用延迟加载：将依赖的类在需要使用时再进行加载，而不是在类初始化时就加载，这样可以避免循环依赖。\n\n使用中介类：引入一个中介类，将相互依赖的类都注入到中介类中，然后再将中介类注入到需要使用的类中，这样可以避免循环依赖。\n\n\n@Lazy注解   @Lazy注解可以延迟加载一个bean，即在需要使用该bean时才会被加载。\n@Lazy\n@Autowired\nprivate  ConfigService configService;\n注意： 使用lombok提供的注解@RequiredArgsConstructor延迟加载会失效，取消final修饰用@Autowired\n","slug":"SpringBoot循环依赖问题","date":"2023-03-17T06:43:31.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"4d178542e742a642ab21284220759956","title":"hexo搭建","content":"hexo搭建\n什么是hexo？   Hexo是一个基于Node.js的静态博客生成器，可以将Markdown格式的文本转换成静态网页的形式。 它支持大量的主题和插件，可以方便地定制自己的博客主题和功能。   Hexo还支持多种发布方式， 包括将生成的静态网页部署到Github Pages、Heroku等云服务上，也可以通过FTP、SSH等方式将博客发布到自己的服务器上。   Hexo是一个非常流行的静态博客生成器，被广泛用于个人博客、技术博客等各种领域。\n安装Hexo的步骤如下：1.安装Node.jsHexo是基于Node.js的，因此需要先安装Node.js。可以在Node.js官网下载对应的安装包进行安装。\n2.安装GitGit是一个版本控制工具，Hexo在安装和部署时需要使用到Git。可以在Git官网下载对应的安装包进行安装。\n3.安装Hexo在命令行中执行以下命令来安装Hexo：\nnpm install -g hexo-cli\n\n4.初始化Hexo博客在命令行中执行以下命令来初始化一个Hexo博客：\nhexo init &lt;folder&gt;\ncd &lt;folder&gt;\nnpm install\n\n其中，folder为博客的文件夹名称，可以自定义。\n5.运行Hexo博客   在命令行中执行以下命令来启动Hexo博客：\nhexo server\n\n然后在浏览器中访问 http://localhost:4000 即可查看Hexo博客。\n\n\n\n\n\n\n\n\n\n详细安装教程，请访问官网 https://hexo.io/zh-cn/\n主题安装 有了博客，当然要简单装饰一下了，安装一个主题，官网自己挑选一个用就可以，当前我用的是 Hexo Aurora 就讲一下这个简单实用。\n安装Hexo Aurora主题的步骤如下：步骤 1 - 安装主题包在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\nnpm install hexo-theme-aurora --save\n步骤 2 - 主题设置 进入Hexo博客的配置文件 _config.yml,找到theme修改为aurora：\ntheme: aurora\n步骤 3 - 设置 permalink进入Hexo博客的配置文件 _config.yml，修改 permalink 参数为 &#x2F;post&#x2F;:title.html\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as &#39;https:&#x2F;&#x2F;username.github.io&#x2F;project&#39;\nurl: https:&#x2F;&#x2F;xiaohai-store.github.io\npermalink: &#x2F;post&#x2F;:title.html\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks\n  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks\n步骤 4 - 设置代码高亮最后主题是使用 Prismjs 来实现代码高亮显示，但 Hexo 默认是使用 highlightjs，因此你需要更改 Hexo 配置来使用 Prismjs:\n\n把 highlight 的启用改为false\n把 prismjs 的启用改为true\n把 prismjs 下的 preprocess 改为 falsehighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: false\n  line_number: true\n  tab_replace: &#39;&#39;\n\n\n\n\n\n\n\n\n\n详细安装教程，请访问官网 https://aurora.tridiamond.tech/zh/\n\n\n快速入门使用创建新文章$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\n运行服务$ hexo server\n\nMore info: Server\n生成静态文件$ hexo generate\n\nMore info: Generating\n部署到远程站点$ hexo deploy\n\nMore info: Deployment\n遇到的问题问题1：文章时间问题需要在md最开始添加一下数据文件，可参考模板目录scaffolds,详细可见官方文档 https://hexo.io/zh-cn/docs/front-matter\n---\ntitle: 标题\ndate: 建立日期\n---\n问题2：分类标签不展示需要完善tags 和 categories，封面添加cover属性，详细可见官方文档 https://hexo.io/zh-cn/docs/front-matter\n---\ntitle: 标题\ndate: 建立日期\ntags: 标签\ncategories: 分类\ncover:  主题封面\n---\n问题3：设置logo不生效 需要将图标放置source文件下才生效\n问题4：社交链接图标 请注意图标名称为 icon 不是 icons 仔细阅读官方文档,搞了大半天是名字问题\n问题5 gitalk评论 中文不要设置为 cn 请设置为zn-CN\nlanguage: zh-CN\n 评论区会展示多个联系人，是因为作者配置文件的问题，到作者主题包下去掉配置文件\n问题6 github部署问题​    我这边采用一键部署\n\n在 GitHub 上创建一个新的仓库，用于存储 Hexo 生成的静态文件。\n\n在本地安装 Hexo，并在 Hexo 根目录下执行以下命令\n\n\nnpm install hexo-deployer-git --save\n​\t这个命令会安装 Hexo 的 Git 部署插件，用于将博客发布到 GitHub 上。\n\n在 Hexo 根目录下的 _config.yml 文件中配置 Git 部署插件，例如：\n\ndeploy:\n   type: git\n   repo: https:&#x2F;&#x2F;key@github.com&#x2F;xiaohai-store&#x2F;xiaohai-store.github.io.git\n   branch: gh-pages\n注意： key 为github的秘钥\n\n生成静态文件并将其部署到 GitHub 上。在 Hexo 根目录下执行以下命令：\n\nhexo generate\nhexo deploy\n\n​\t这个命令会将 Hexo 生成的静态文件部署到指定的 GitHub 仓库中。\n\n确认发布成功。访问你的 GitHub Pages 地址，检查博客是否已经成功发布到新的仓库中。\n\n","slug":"blog/hexo搭建/hexo搭建","date":"2023-03-16T01:43:19.000Z","categories_index":"blog","tags_index":"blog","author_index":"小海"},{"id":"44f3816acae6092110e3c35d6f574b7f","title":"OpenAPI规范和SpringDoc使用","content":"OpenAPI规范和SpringDoc使用\n1. 简介OpenAPI规范(OAS)，以前称为Swagger 规范，是一种机器可读的接口定义语言的规范，用于描述、生成、使用和可视化RESTful Web 服务。它以前是Swagger框架的一部分，在 2016 年成为一个单独的项目，由 OpenAPI Initiative 监督，OpenAPI Initiative 是Linux 基金会的一个开源协作项目。 Swagger 和其他一些工具可以从接口文件生成代码、文档和测试用例。\n2. 规范2.1 文档版本OpenAPI 规范使用语义版本控制 2.0.0 (semver) 进行版本控制，并遵循 semver 规范。\n2.2 文档格式OpenAPI文档本身是一个JSON对象，可以用JSON或YAML格式表示。\n字段名称区分大小写。\n2.3 数据类型\nOAS的原始数据类型基于JSON Schema Specification Wright Draft 00，并做了一定的扩展。\n\n原始类型有一个可选的修饰属性：format。规范指定了一部分format类型，但也可以对其进行扩展，比如使用email，uuid等，只要能被工具解析即可。\n\nOAS定义的格式如下：\n\n\n\ntype\nformat\n备注\n\n\n\ninteger\nint32\n32 位有符号 (byte, short, int)\n\n\ninteger\nint64\n64 位有符号（long类型）\n\n\nnumber\nfloat\n\n\n\nnumber\ndouble\n\n\n\nstring\n\n\n\n\nstring\nbyte\nbase64编码的字符\n\n\nstring\nbinary\n任何八位字节序列\n\n\nboolean\n\n\n\n\nstring\ndate\n由RFC3339定义定义的full-date\n\n\nstring\ndate-time\n由RFC3339定义的date-time\n\n\nstring\npassword\n提示界面不应明文输入\n\n\n\n\n2.4 富文本格式规范中的**description**字段支持Markdown格式。\n3. 框架3.1 固定字段\n\n\n字段名\n类型\n是否必需\n描述\n\n\n\nopenapi\nstring\n是\nOpenAPI规范的版本号。\n\n\ninfo\nInfo 对象\n是\nAPI相关的元数据。\n\n\nservers\n[Server 对象]\n否\nServer对象的数组， 提供到服务器的连接信息\n\n\npaths\nPaths 对象\n是\nAPI的可用路径和操作。\n\n\ncomponents\nComponent 对象\n否\n一个包含多种结构的组件\n\n\nsecurity\n[Security Requirement 对象]\n否\n可以在 API 中使用哪些安全机制的声明\n\n\ntags\n[Tag 对象]\n否\n带有附加元数据的标签列表，每个标签名称必须是唯一的\n\n\nexternalDocs\nExternal Documentation 对象\n否\n额外的外部文档。\n\n\n\n3.2 Paths 对象Paths:\n  PathItem:\n    Operation:     # @Operation注解，http方法根据 @GetMapping @PostMapping等注解判断\n      - summary           # @Operation(summary &#x3D; &quot;保存用户信息&quot;, description &#x3D; &quot;保存用户信息&quot;) 对应summary\n      - description       # @Operation(summary &#x3D; &quot;保存用户信息&quot;, description &#x3D; &quot;保存用户信息&quot;) 对应description\n      - tags              # 指定tag\n      - parameters        # url参数，对应@Parameter注解，如果参数放在了类中，需要在类上添加@ParameterObject注解\n      - requestBody       # requestBody，对应@RequestBody注解的类\n      - responses         # responseBody，controller方法的返回对象\n\n3.3 Operation对象\n描述路径上的单个API操作。包括get, post, delete, put, options等\n\n常用字段\n\n\n\n字段名\n类型\n描述\n\n\n\nsummary\nstring\n该操作的作用的简短摘要。\n\n\ndescription\nstring\n对操作行为的详细解释。支持markdown语法\n\n\nparameters\n[Parameter对象 或 Reference对象]\n适用于此操作的参数列表\n\n\nrequestBody\nRequest Body对象 或 Reference对象\n适用于此操作的请求正文\n\n\nresponses\nResponses 对象\n执行此操作返回的可能响应列表\n\n\ntags\n[string]\nAPI 文档控制的标签列表\n\n\n\n配置方式\n@Operation(summary &#x3D; &quot;获取用户列表&quot;,\n        description &#x3D; &quot;&quot;&quot;\n                &lt;b&gt;获取*用户*列表&lt;&#x2F;b&gt;\n                - username: 用户名\n                - status: 状态\n                &quot;&quot;&quot;\n)\n@GetMapping(&quot;users&quot;)\npublic List&lt;UserDTO&gt; getUsers(@ParameterObject UserQuery query) &#123;\n    var userDTO &#x3D; getUser();\n    return List.of(userDTO);\n&#125;\n\n3.4 Parameter对象\n描述单个操作的参数，通过in字段定义了4种不同的参数位置\n\npath - URL中的参数。例如items/&#123;itemId&#125;，itemId是路径参数\n\nquery - 附加在URL后的参数。例如items?id=1，请求参数为id\n\nheader - 自定义header中参数\n\ncookie - 通过cookie传的参数\n\n\n\n常用字段：\n\n\n\n字段名\n类型\n描述\n\n\n\nname\nstring\n字段名，用默认值，不要做任何修改\n\n\nin\nstring\n参数的位置，包括path, query, header, cookie4种，不需要设置\n\n\ndescription\nstring\n参数的描述，支持markdown\n\n\nrequired\nboolean\n参数是否必需。path中的参数必须设置成true\n\n\ndeprecated\nboolean\n参数是否废弃\n\n\nschema\nSchema对象\n定义用于参数的类型的模式。\n\n\nexample\nAny\n参数示例\n\n\n\n配置方式\n@Parameter(\n        description &#x3D; &quot;&quot;&quot;\n                状态\n                - 1: 启用\n                - 2: 禁用\n                - 3: 锁定\n                &quot;&quot;&quot;,\n        required &#x3D; true,\n        schema &#x3D; @Schema(allowableValues &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, type &#x3D; &quot;integer&quot;))\nprivate Byte status;\n\n3.5 Request Body 对象请求体，添加@RequestBody即可\n3.6 Response 对象方法的返回值\n3.7 Schema对象\nSchema对象定义输入和输出数据类型。这些类型可以是对象，也可以是基础类型和数组\n\n常用的字段有title, maxLength, minLength, maximum, minimum, pattern, enum 等\n\n使用方式：一般是在DTO、VO的字段上使用\n@Schema(title &#x3D; &quot;用户名&quot;)\nprivate String username;\n\n3.8 Tag对象\n使用Tag对象添加元数据，作用于Operation对象上\n\n使用方法\n@Tag(name &#x3D; &quot;user&quot;, description &#x3D; &quot;涉及用户的操作，包括增删改查等操作&quot;)\n@RestController\npublic class UserController &#123;\n\n3.9 扩展扩展属性需要以x-开头。\n以openapi-generator为例，该工具扩展了enum属性，添加了x-enum-varnames等字段，用来表示enum的值。我们可以通过@Extention注解来实现属性扩展。\n@Schema(title &#x3D; &quot;状态&quot;,\n            type &#x3D; &quot;integer&quot;,\n            allowableValues &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;,\n            extensions &#x3D; @Extension(\n                    properties &#x3D; @ExtensionProperty(\n                            name &#x3D; &quot;enum-varnames&quot;,\n                            value &#x3D; &quot;&quot;&quot;\n                                    [&quot;启用&quot;,&quot;禁用&quot;,&quot;锁定&quot;]\n                                    &quot;&quot;&quot;,\n                            parseValue &#x3D; true\n                    )\n            ))\nprivate Byte status;\n\n\n\n4. SpringDoc 使用\nController类上使用@Tag注解，方法上使用@Operation注解\n\n@Tag注解的name可以不配置，默认是类名(短横线连接)，如果配置，则必须使用英文\n\n需要区分请求参数和RequestBody。请求参数字段使用@Parameter注解，RequestBody中的字段使用@Schema注解\n\n请求参数数量超过2个时，应将封装在一个Query类中，并在该类上使用@ParameterObject注解，类的字段使用@Parameter注解\n\nByte，Short类型，SpringDoc会识别为string类型，应将其手动设置成integer类型，设置方法如下\n&#x2F;&#x2F; schema的设置方式\n@Schema(title &#x3D; &quot;状态&quot;,type &#x3D; &quot;integer&quot;)\nprivate Byte status;\n&#x2F;&#x2F; parameter的设置方式\n@Parameter(description &#x3D; &quot;状态&quot;, schema &#x3D; @Schema(type &#x3D; &quot;integer&quot;))\nprivate Byte status;\n\n枚举类需要通过@Schema注解的allowableValues参数进行配置。openapi-generator工具使用了扩展字段x-enum-varnames来描述枚举对应的值，扩展字段可以通过@Extension注解来实现，示例如下\n@Schema(title &#x3D; &quot;状态&quot;,\n        type &#x3D; &quot;integer&quot;,\n        allowableValues &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &#x2F;&#x2F; 枚举值\n        extensions &#x3D; @Extension(\n                properties &#x3D; @ExtensionProperty(\n                        name &#x3D; &quot;enum-varnames&quot;,  &#x2F;&#x2F; 扩展字段的字段名，会自动添加&#96;x-&#96;前缀\n                        value &#x3D; &quot;&quot;&quot;\n                                [&quot;启用&quot;,&quot;禁用&quot;,&quot;锁定&quot;]\n                                &quot;&quot;&quot;, &#x2F;&#x2F; 固定设置为json array格式，array中的每个值与allowableValues中的枚举值对应\n                        parseValue &#x3D; true &#x2F;&#x2F; 设置true，可将value解析成array\n                )\n        ))\nprivate Byte status;\n\nSpringDoc支持常用的JSR-303注解，如*@NotNull*, @NotBlank, @Size, @Min, @Max 等\n\n注意书写规范，方法名、参数名、成员变量、局部变量必须使用lowerCamelCase风格，类名使用 UpperCamelCase 风格。\n\n文件上传，需要将 Content-Type 设置为 multipart&#x2F;form-data ，设置方法是将 @PostMapping的 consumes 属性设置为 multipart&#x2F;form-data 。示例如下：\n@Operation(summary &#x3D; &quot;上传文件&quot;)\n@PostMapping(value &#x3D; &quot;upload-file&quot;, consumes &#x3D; MediaType.MULTIPART_FORM_DATA_VALUE)\npublic void upload(@RequestBody MultipartFile file) &#123;\n&#125;\n\n附录\n参考\n\nDocumenting a Spring REST API Using OpenAPI 3.0\nOpenAPI Specification\nopenapi-generator文档\nSpringdoc文档\n\n\n一份完整的OpenApi文档\n\n\n&#123;\n    &quot;openapi&quot;: &quot;3.0.1&quot;,\n    &quot;info&quot;: &#123;\n        &quot;title&quot;: &quot;openapi示例&quot;,\n        &quot;description&quot;: &quot;用于演示Springdoc的用法&quot;,\n        &quot;version&quot;: &quot;1.0.0&quot;\n    &#125;,\n    &quot;servers&quot;: [\n        &#123;\n            &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&quot;,\n            &quot;description&quot;: &quot;Generated server url&quot;\n        &#125;\n    ],\n    &quot;security&quot;: [\n        &#123;\n            &quot;authentication&quot;: []\n        &#125;\n    ],\n    &quot;tags&quot;: [\n        &#123;\n            &quot;name&quot;: &quot;role&quot;,\n            &quot;description&quot;: &quot;涉及用户的操作，包括增删改查等操作&quot;\n        &#125;,\n        &#123;\n            &quot;name&quot;: &quot;user&quot;,\n            &quot;description&quot;: &quot;涉及用户的操作，包括增删改查等操作&quot;\n        &#125;\n    ],\n    &quot;paths&quot;: &#123;\n        &quot;&#x2F;users&quot;: &#123;\n            &quot;get&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;user&quot;\n                ],\n                &quot;summary&quot;: &quot;获取用户列表&quot;,\n                &quot;description&quot;: &quot;&lt;b&gt;获取*用户*列表&lt;&#x2F;b&gt;\\n- username: 用户名\\n- status: 状态\\n&quot;,\n                &quot;operationId&quot;: &quot;getUsers&quot;,\n                &quot;parameters&quot;: [\n                    &#123;\n                        &quot;name&quot;: &quot;username&quot;,\n                        &quot;in&quot;: &quot;query&quot;,\n                        &quot;description&quot;: &quot;用户名&quot;,\n                        &quot;required&quot;: false,\n                        &quot;schema&quot;: &#123;\n                            &quot;type&quot;: &quot;string&quot;\n                        &#125;\n                    &#125;,\n                    &#123;\n                        &quot;name&quot;: &quot;status&quot;,\n                        &quot;in&quot;: &quot;query&quot;,\n                        &quot;description&quot;: &quot;状态\\n- 1: 启用\\n- 2: 禁用\\n- 3: 锁定\\n&quot;,\n                        &quot;required&quot;: false,\n                        &quot;schema&quot;: &#123;\n                            &quot;maximum&quot;: 3,\n                            &quot;minimum&quot;: 1,\n                            &quot;type&quot;: &quot;integer&quot;,\n                            &quot;enum&quot;: [\n                                &quot;1&quot;,\n                                &quot;2&quot;,\n                                &quot;3&quot;\n                            ]\n                        &#125;\n                    &#125;\n                ],\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;type&quot;: &quot;array&quot;,\n                                    &quot;items&quot;: &#123;\n                                        &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserDTO&quot;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;,\n            &quot;post&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;user&quot;\n                ],\n                &quot;summary&quot;: &quot;保存用户信息&quot;,\n                &quot;operationId&quot;: &quot;saveUser&quot;,\n                &quot;requestBody&quot;: &#123;\n                    &quot;content&quot;: &#123;\n                        &quot;application&#x2F;json&quot;: &#123;\n                            &quot;schema&quot;: &#123;\n                                &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserVO&quot;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;required&quot;: true\n                &#125;,\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserDTO&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\n        &quot;&#x2F;users&#x2F;&#123;id&#125;&quot;: &#123;\n            &quot;get&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;user&quot;\n                ],\n                &quot;summary&quot;: &quot;获取单个用户信息&quot;,\n                &quot;operationId&quot;: &quot;getUser&quot;,\n                &quot;parameters&quot;: [\n                    &#123;\n                        &quot;name&quot;: &quot;id&quot;,\n                        &quot;in&quot;: &quot;path&quot;,\n                        &quot;description&quot;: &quot;用户id&quot;,\n                        &quot;required&quot;: true,\n                        &quot;schema&quot;: &#123;\n                            &quot;type&quot;: &quot;string&quot;\n                        &#125;\n                    &#125;\n                ],\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserDTO&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\n        &quot;&#x2F;roles&quot;: &#123;\n            &quot;get&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;role&quot;\n                ],\n                &quot;operationId&quot;: &quot;getRoles&quot;,\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;type&quot;: &quot;array&quot;,\n                                    &quot;items&quot;: &#123;\n                                        &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;RoleDTO&quot;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;,\n    &quot;components&quot;: &#123;\n        &quot;schemas&quot;: &#123;\n            &quot;ResponseError&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;code&quot;: &#123;\n                        &quot;title&quot;: &quot;异常代码&quot;,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;400&quot;\n                    &#125;,\n                    &quot;message&quot;: &#123;\n                        &quot;title&quot;: &quot;异常信息&quot;,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;该参数不能为空&quot;\n                    &#125;,\n                    &quot;errors&quot;: &#123;\n                        &quot;type&quot;: &quot;object&quot;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;,\n            &quot;UserVO&quot;: &#123;\n                &quot;required&quot;: [\n                    &quot;phone&quot;,\n                    &quot;username&quot;\n                ],\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;username&quot;: &#123;\n                        &quot;title&quot;: &quot;用户名&quot;,\n                        &quot;maxLength&quot;: 20,\n                        &quot;minLength&quot;: 5,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;admin&quot;\n                    &#125;,\n                    &quot;nickname&quot;: &#123;\n                        &quot;title&quot;: &quot;昵称&quot;,\n                        &quot;maxLength&quot;: 20,\n                        &quot;minLength&quot;: 0,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;dongting&quot;\n                    &#125;,\n                    &quot;phone&quot;: &#123;\n                        &quot;title&quot;: &quot;手机号&quot;,\n                        &quot;pattern&quot;: &quot;^1[3-9][0-9]&#123;9&#125;$&quot;,\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;,\n            &quot;UserDTO&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;id&quot;: &#123;\n                        &quot;title&quot;: &quot;主键&quot;,\n                        &quot;type&quot;: &quot;integer&quot;,\n                        &quot;format&quot;: &quot;int64&quot;\n                    &#125;,\n                    &quot;username&quot;: &#123;\n                        &quot;title&quot;: &quot;用户名&quot;,\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;,\n                    &quot;nickname&quot;: &#123;\n                        &quot;title&quot;: &quot;昵称&quot;,\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;,\n                    &quot;avatar&quot;: &#123;\n                        &quot;title&quot;: &quot;头像&quot;,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;用户头像，base64&quot;,\n                        &quot;format&quot;: &quot;byte&quot;\n                    &#125;,\n                    &quot;status&quot;: &#123;\n                        &quot;title&quot;: &quot;状态&quot;,\n                        &quot;type&quot;: &quot;integer&quot;,\n                        &quot;format&quot;: &quot;int32&quot;,\n                        &quot;enum&quot;: [\n                            1,\n                            2,\n                            3\n                        ],\n                        &quot;x-enum-varnames&quot;: [\n                            &quot;启用&quot;,\n                            &quot;禁用&quot;,\n                            &quot;锁定&quot;\n                        ]\n                    &#125;,\n                    &quot;roles&quot;: &#123;\n                        &quot;title&quot;: &quot;角色&quot;,\n                        &quot;type&quot;: &quot;array&quot;,\n                        &quot;items&quot;: &#123;\n                            &quot;title&quot;: &quot;角色&quot;,\n                            &quot;type&quot;: &quot;string&quot;\n                        &#125;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;,\n            &quot;RoleDTO&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;name&quot;: &#123;\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;\n        &#125;,\n        &quot;securitySchemes&quot;: &#123;\n            &quot;authentication&quot;: &#123;\n                &quot;type&quot;: &quot;apiKey&quot;,\n                &quot;name&quot;: &quot;authentication&quot;,\n                &quot;in&quot;: &quot;header&quot;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n","slug":"OpenAPI规范和SpringDoc使用","date":"2023-03-10T03:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"d459146c27d3881c39d30204014457f4","title":"nvm for windows 下载、安装及使用","content":"nvm for windows 下载、安装及使用\nnvm是node版本管理工具，可以运行在多种操作系统上。这里主要记录一下在windows系统的安装和使用。\n下载NVM for Windows 下载地址： github.com&#x2F;coreybutler…\n 只需点击第三个，下载安装包，下载之后点击安装，无需配置就可以使用，十分方便。\n简单说明：\n\nnvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置\nnvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。\nSource code(zip)：zip压缩的源码\nSourc code(tar.gz)：tar.gz的源码，一般用于*nix系统\n\n安装\n第一安装目录：这里没有使用默认的安装目录，修改安装目录为 D:\\nvm\\ ；读者可自行决定安装目录\n第二安装目录：添加 node.js 的安装目录 这里用 “添加 node.js 的安装目录” 的说法其实不太准确，准确的说法应该是配置 node.js 的安装目录；默认会使用 C:\\Program Files\\nodejs 目录，C:\\Program Files\\nodejs 目录也是 node.js 默认的安装目录；如果读者在安装 nvm 前就已经安装了 node.js，且修改了 node.js 的安装目录，那么此处的目录要修改为 node.js 的安装目录；如果读者在安装 nvm 前没有安装 node.js，那么此处的目录可自行定义\n第三点击安装，在安装过程中会弹出：由于已经安装了 node，所以此时提示“你希望nvm管理已经安装的 node 版本吗”，点击 是待安装完成后测试是否安装成功\n\nnvm -v\n复制代码\n\n\n命令使用nvm for windows是一个命令行工具，在控制台输入nvm,就可以看到它的命令用法。基本命令有：\n\nnvm arch [32|64] ： 显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构。\nnvm install  [arch]： 该可以是node.js版本或最新稳定版本latest。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为all以安装32和64位版本。在命令后面添加–insecure ，可以绕过远端下载服务器的SSL验证。\nnvm list [available]： 列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表。这个命令可以简写为nvm ls [available]。\nnvm on： 启用node.js版本管理。\nnvm off： 禁用node.js版本管理(不卸载任何东西)\nnvm proxy [url]： 设置用于下载的代理。留[url]空白，以查看当前的代理。设置[url]为none删除代理。\nnvm node_mirror [url]：设置node镜像，默认为nodejs.org&#x2F;dist&#x2F;.。建议设置…\nnvm npm_mirror [url]：设置npm镜像，默认为github.com&#x2F;npm&#x2F;npm&#x2F;arc…\nnvm uninstall ： 卸载指定版本的nodejs。\nnvm use [version] [arch]： 切换到使用指定的nodejs版本。可以指定32&#x2F;64位[arch]。nvm use 将继续使用所选版本，但根据提供的值切换到32&#x2F;64位模式的\nnvm root [path]： 设置 nvm 存储node.js不同版本的目录 ,如果未设置，将使用当前目录。\nnvm version： 显示当前运行的nvm版本，可以简写为nvm v 常用命令：\nnvm ls 查看已经安装的所有nodejs版本\\\nnvm install 版本号，可安装指定版本的nodejs\\\nnvm use 版本号，即可切换到指定版本\\\nnvm uninstall 版本号，卸载指定版本\n\n注意：在使用nvm-window 时得环境变量的配置，尤其Path 是否正确。\n作者：沐溪兮链接：https://juejin.cn/post/7074108351524634655\n","slug":"nvm for windows 下载、安装及使用","date":"2023-02-26T10:19:42.000Z","categories_index":"web","tags_index":"web","author_index":"小海"},{"id":"cfd6516cec60dd52fbe0026aa3ac0713","title":"Java8-17 新特性（二）","content":"Java8-17 新特性（二）Java91. Java平台模块系统(JPMS)1.1 模块\n模块是一个命名的、自描述的代码和数据集合(A module is a named, self-describing collection of code and data.)。它是一组包含类型的包(package)的集合，也包括其他一些静态资源。\n模块可以理解为package的上级容器，可以控制一个package是否对外暴露(exports)，从而实现更精细化的访问控制。\n\n1.2 模块化的使用方式如何把一个普通项目变成模块化项目？\n\n首先添加一个模块描述符(module-info.java)文件，并定义模块名称：\nmodule insoundai.api &#123;\n&#125;\n\n以上我们定义了一个名为insoundai.api的模块。\n\n然后暴露(exports)我们需要让别人访问的包(package)\nmodule insoundai.api &#123;\n    exports com.insoundai.api;\n&#125;\n\n这样别的模块引用insoundai.api模块时，就可以调用com.insoundai.api包下面的类或其他资源了。\n\n如果我们需要引用其他模块的类，必须先用requires导入这个模块\nmodule insoundai.api &#123;\n    requires insoundai.util;\n\n    exports com.insoundai.api;\n&#125;\n\n有时候，我们希望调用本模块时，被我们引用的模块也能暴露出去。比如我们暴露某个Service，这个Service用到的实体类却是别的模块的，那我们希望Service跟这个实体类一起暴露出去。这时我们可以用requires transitive，来表示这个模块的引用是可以被传递的。\nmodule insoundai.api &#123;\n    requires transitive insoundai.persistence;\n    requires insoundai.util;\n\n    exports com.insoundai.api;\n&#125;\n\n当别的模块引用insoundai.api模块时，insoundai.persistence模块会同时被引入。\n\n有的模块只需要编译时存在，比如lombok，我们可以用requires static来声明：\nmodule insoundai.persistence &#123;\n    requires static lombok;\n    exports com.insoundai.persistence.entity;\n&#125;\n\nopens用于声明仅运行时可访问的包，这些包的内容可以通过反射获取。这对Spring项目非常有用，我们声明的Spring Bean都需要通过这种方式让spring调用到。\nmodule insoundai.api &#123;\n    requires transitive insoundai.persistence;\n    requires insoundai.util;\n    requires spring.context;\n\n    opens com.insoundai.api.impl to spring.beans;\n\n    exports com.insoundai.api;\n&#125;\n\n1.3 模块化的好处1.3.1. 可靠性配置通过显式地声明组件之间的依赖关系，取代脆弱、易出错的类路径机制。\n1.3.2 强封装允许组件声明它的哪些公共类型可以被其他组件访问，哪些不能。\n1.4 与Maven多模块的区别\nMaven的模块都可以作为单独的项目存在，都有自己的pom文件，可以打成单独的jar包。Maven多模块一般只用于复杂的项目，是基于某种缘由对项目的拆分。\nJMPS关注的是项目内包的管理，用来控制项目内的包是否能被外部访问到。\n\n2. JShell\nJShell是一个交互式工具(REPL)。它在输入声明、语句和表达式时计算它们，并立即显示结果。该工具从命令行运行。\n$ jshell\njshell&gt; System.out.println(&quot;hello world&quot;);\nhello world\n\njshell&gt; int x &#x3D; 0;\nx &#x3D;&#x3D;&gt; 0\njshell&gt; for (int i &#x3D; 0;i &lt; 10;i++) &#123;\n   ...&gt;     x +&#x3D; i;\n   ...&gt; &#125;\njshell&gt; System.out.println(x);\n45\n\n3. 快速创建不可变集合\n增加了List.of()、Set.of()、Map.of() 和 Map.ofEntries()等工厂方法来创建不可变集合\nList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nMap.of(&quot;k1&quot;, &quot;val1&quot;, &quot;k2&quot;, &quot;val2&quot;);\n\nJava10局部变量类型推断\nJava10提供了局部变量的类型推断。局部变量初始化时，可以用var替代显式的变量类型声明。\nvar text &#x3D; &quot;Hello World!&quot;;\n\nvar不是关键字，而是保留的类型名称。这保证了var作为函数名或变量名的向后兼容性。\n\n变量的类型信息会在编译时通过等号右侧信息推断出来，因此var的使用不会对Java运行时的性能产生影响，也不会使Java变成动态语言。\n\nvar是一把双刃剑，使用得当会有效提升代码的可读性，使用不好则会让代码可读性变得更差。以下是一些使用建议：\n\n变量命名中提供了足够的信息\n&#x2F;&#x2F; 显式类型\nList&lt;User&gt; list &#x3D; obj.handle();\n\n&#x2F;&#x2F; var方式\nvar userList &#x3D; obj.handle();\n\n变量初始化过程中包含了足够的信息\n&#x2F;&#x2F; 显式类型\nByteArrayOutputStream outputStream &#x3D; new ByteArrayOutputStream();\nList&lt;String&gt; stringList &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\n&#x2F;&#x2F; var方式\nvar outputStream &#x3D; new ByteArrayOutputStream();\nvar stringList &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\nfor循环或try-with-resources中，可以考虑使用var\n&#x2F;&#x2F; 显式类型\nfor (Iterator&lt;String&gt; iterator &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).iterator(); iterator.hasNext();) &#123;\n    String string &#x3D; iterator.next();\n&#125;\n&#x2F;&#x2F; var方式\nfor (var iterator &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).iterator(); iterator.hasNext();) &#123;\n    var userType &#x3D; iterator.next();\n&#125;\n\n\nvar的错误用法\nvar a; &#x2F;&#x2F; 没有初始化变量\nvar b &#x3D; null; &#x2F;&#x2F; 不能初始化为null\npublic var c &#x3D; &quot;d&quot;; &#x2F;&#x2F; 不能用于非局部变量\nvar e &#x3D; (String s) -&gt; s.length() &gt; 1; &#x2F;&#x2F; lambda表达式需要显式类型信息\nvar arr &#x3D; &#123;1, 2, 3&#125; &#x2F;&#x2F; 不能用于数组初始化\n\nJava111. String新方法1.1  repeat()\n将字符串重复n次\n\nString text &#x3D; &quot;呼&quot;.repeat(2) + &quot;大睡&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt; &quot;呼呼大睡&quot;\n\n1.2  strip系列方法\n去除头尾的空格，包括strip(), stripLeading(), stripTrailing()三个方法。\n\nString text &#x3D; &quot;\\n\\t  hello  \\u2005\\u001C&quot;;\nSystem.out.println(text.strip().equals(&quot;hello&quot;));\n\n&gt;&gt;&gt; true\n\n\n与trim()的不同点\ntrim() 方法判断空格的依据是Unicode代码小于或等于空格符(U+0020)，包括常见的换行符和Tab。\nstrip() 方法的判断依据是Character.isWhitespace()方法，即Unicode空白字符串，范围更广。\n\n\n\n1.3  isBlank()方法\n判断字符串是否为空或只包含空格，空格的判断与strip()相同。\n\nString text &#x3D; &quot;\\n\\t\\u2005  &quot;;\nSystem.out.println(&quot;\\n\\t\\u2005  &quot;.isBlank());\n\n&gt;&gt;&gt; true\n\n1.4  lines() 方法\n通过行终止符(\\n, \\r或\\r\\n)分割字符串，并返回一个 Stream。\n\nString text &#x3D; &quot;每天\\n都能\\r准时\\r\\n下班&quot;;\nList&lt;String&gt; lines &#x3D; text.lines().collect(Collectors.toList());\nSystem.out.println(lines);\n\n&gt;&gt;&gt; [每天, 都能, 准时, 下班]\n\n2. Http Client\nJava11 提供了新的Http客户端，实现了Http和WebSocket的客户端API标准化。\n\n新的 API 为 HTTP 1.1&#x2F;2和WebSocket 提供了原生支持。提供核心功能的核心类和接口包括：\n\nHttpClient类，java.net.http.HttpClient\n\nHttpRequest类，java.net.http.HttpRequest\n\nHttpResponse 接口，java.net.http.HttpResponse\n\nWebSocket接口，java.net.http.WebSocket\n\n\n\n\n&#x2F;&#x2F; 创建 httpRequest\nHttpRequest request &#x3D; HttpRequest.newBuilder()\n    .uri(new URI(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;test&#x2F;1&quot;))\n    .header(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)\n    .header(&quot;Accept&quot;, &quot;application&#x2F;json&quot;)\n    .timeout(Duration.ofSeconds(10))\n    .POST(HttpRequest.BodyPublishers.ofString(&quot;&#123;\\&quot;score\\&quot;:\\&quot;1\\&quot;&#125;&quot;))\n    .build();\n&#x2F;&#x2F; 创建 httpClient\nHttpClient client &#x3D; HttpClient.newHttpClient();\n&#x2F;&#x2F; 由httpClient发送请求，获取响应数据\nHttpResponse&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());\nHttpHeaders headers &#x3D; response.headers();\nString body &#x3D; response.body();\n\n\n\n3. Java文件运行方式Java11之前需要用javac编译源文件\n$ javac HelloWorld.java\n$ java HelloWorld\n\nHello Java 8!\n\n现在可以直接运行Java文件\n$ java HelloWorld.java\n\nHello Java 11!\n\n4. OpenJDK\nJava11 开始，Oracle JDK 与 OpenJDK 已没有本质的区别\n\n参考资料：\n\nWhat Modules Are About\nThe State of the Module System\nJava9新特性中的模块化到底是什么\nIntroduction to Project Jigsaw\n局部变量类型推断风格指南\n\n","slug":"Java8-17 新特性（二）","date":"2023-02-17T08:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"a4afb430c2cbd3b47233ae51001f2621","title":"Java8-17 新特性（一）","content":"Java8-17 新特性（一）Java81. 接口默认方法和静态方法\n1.1 默认方法默认方法需要用新的关键字default来定义。默认方法可以通过实现类的实例进行访问，并且可以被重写。\npublic interface UserDao &#123;\n    default Optional&lt;User&gt; getUserByUsername(String username) &#123;\n        User user &#x3D; new User();\n        user.setUsername(username);\n        return Optional.of(user);\n    &#125;\n&#125;\n\n1.2 静态方法静态方法不能被重写。\npublic interface UserDao &#123;\n    \n    static Optional&lt;User&gt; getUser(String username) &#123;\n        return Optional.of(new User());\n    &#125;\n&#125;\n\n2. 函数式接口\n函数式接口是指只包含一个抽象方法的接口。函数式接口可以存在多个默认方法，因为它并不是抽象方法。\n\n函数式接口一般通过@FunctionalInterface来声明，但该注解并不是必须的，只要符合上述定义的接口都会被编译器认为是函数式接口。\n\n函数式接口的实例可以通过lambda表达式、方法引用或构造函数引用来创建。\n\n函数式接口有几种基础的形态：\n\nFunction —— 一元函数，接受一个参数并返回一个结果\nConsumer —— 一元函数，接受一个参数，但不返回任何结果\nPredicate —— 一元函数，表示一个参数的断言，返回布尔值\nSupplier —— 零元函数，结果的提供者，不接受参数，只返回结果\n\n\n特定的前缀表示了对基础形态特定的扩展\n\n带元数的前缀，比如Bi前缀，代表二元函数(binary function)，BiConsumer代表接受两个参数，但不返回任何结果\n带类型的前缀，分两种，前缀如果是ToXxx，代表返回值类型是Xxx，否则代表入参的类型。例如ObjIntConsumer代表接受一个泛型参数和int类型参数，ToIntFunction表示返回值是int类型。\n其他派生函数，包括UnaryOperator(extends Function)和BinaryOperator(extends BiFunction)，这两种函数输入值与输出值的类型是一致的。\n\n\n\n\n3. Lambda表达式3.1 lambda表达式\nlambda 表达式是一个可传递的代码块，也被称为闭包(closures)或匿名方法(anonymous methods)。\n\nlambda具有更强的表现力和更简洁的代码，使我们更加关注做什么而非怎么做。\n\nlambda 本质上由三部分组成：一组带括号的参数、一个箭头和一个主体，它可以是单个表达式或 Java 代码块。\nRunnable r &#x3D; () -&gt; &#123;&#125;;\n\n3.2 方法引用方法引用是一种特殊类型的 lambda 表达式。它们通常用于通过引用现有方法来创建简单的 lambda 表达式。\n方法引用有四种：\n\n静态方法\n&#x2F;&#x2F; System.out.println(&quot;&quot;);\nList.of(&quot;a&quot;, &quot;b&quot;).forEach(System.out::println);\n\n特定对象的实例方法\npublic class Comparator &#123;\n    public int compare(User a, User b) &#123;\n        return a.getAge().compareTo(b.getAge());\n    &#125;\n&#125;\n\n@Data\npublic class User &#123;\n    public User() &#123;\n    &#125;\n    public User(String username, Integer age) &#123;\n        this.username &#x3D; username;\n        this.age &#x3D; age;\n    &#125;\n    private String username;\n    private Integer age;\n\n    public static void main(String[] args) &#123;\n        Comparator comparator &#x3D; new Comparator();\n        List&lt;User&gt; list &#x3D; Stream.of(new User(&quot;a&quot;, 42), new User(&quot;b&quot;, 23))\n                .sorted(comparator::compare)\n                .collect(Collectors.toList());\n        System.out.println(list);\n    &#125;\n&#125;\n&gt;&gt;&gt; [User(username&#x3D;b, age&#x3D;23), User(username&#x3D;a, age&#x3D;42)]\n\n\n\n特定类型的任意对象的实例方法\n&#x2F;&#x2F; &quot;a&quot;.toUpperCase();\nList&lt;String&gt; list &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;).map(String::toUpperCase).collect(Collectors.toList());\nSystem.out.println(list);\n\n\n\n构造函数\n@Data\npublic class User &#123;\n    public User() &#123;\n    &#125;\n    public User(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n    private String username;\n&#125;\n\npublic static void main(String[] args) &#123;\n    List&lt;User&gt; list &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;).map(User::new).collect(Collectors.toList());\n    System.out.println(list);\n&#125;\n\n4. Streams\nJava的流(Stream)，遵循“做什么而非怎么做”的原则。\n\n流管道包括一个源（数组、集合、生成器函数、I&#x2F;O通道等）、零个或多个中间操作（intermediate operation，将一个流转换为另一个流）和一个终端操作（产出结果）\n\n流是惰性的，仅在启动终端操作时才对源数据进行计算，并且仅在需要时使用源数据\nStream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)\n    .filter(s -&gt; &#123;\n        System.out.println(&quot;filter: &quot; + s);\n        return s.startsWith(&quot;a&quot;); \n    &#125;)\n    .map(s -&gt; &#123;\n        System.out.println(&quot;map: &quot; + s);\n        return s.toUpperCase();\n    &#125;)\n    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));\n\n\n\nStream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)\n    .sorted((s1, s2) -&gt; &#123;\n        System.out.printf(&quot;sort: %s; %s\\n&quot;, s1, s2);\n        return s1.compareTo(s2); \n    &#125;) \n    .filter(s -&gt; &#123;\n        System.out.println(&quot;filter: &quot; + s);\n        return s.startsWith(&quot;a&quot;); \n    &#125;)\n    .map(s -&gt; &#123;\n        System.out.println(&quot;map: &quot; + s);\n        return s.toUpperCase(); \n    &#125;)\n    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));\n\n&#x2F;&#x2F; 第一个结果\nfilter: d2\nfilter: a2\nmap: a2\nforEach: A2\nfilter: b1\nfilter: b3\nfilter: c\n\n&#x2F;&#x2F; 第二个结果\nsort: a2; d2\nsort: b1; a2\nsort: b1; d2\nsort: b1; a2\nsort: b3; b1\nsort: b3; d2\nsort: c; b3\nsort: c; d2\nfilter: a2\nmap: a2\nforEach: A2\nfilter: b1\nfilter: b3\nfilter: c\nfilter: d2\n\n流是不能被复用的，一旦你调用任何终端操作，流就会关闭\n\n常用的中间操作有：filter, map, flatMap, sorted, peek, limit, skip, distinct等\n\n常用的终端操作有：forEach, toArray, reduce, collect, min, max, findFirst, count, anyMatch等\nList&lt;List&lt;String&gt;&gt; list &#x3D; List.of(List.of(&quot;a&quot;, &quot;b&quot;), List.of(&quot;c&quot;, &quot;d&quot;));\nlist.stream()\n    .flatMap(l -&gt; &#123;\n            System.out.println(&quot;flat map: &quot; + l);\n            return l.stream();\n        &#125;)\n        .map(s -&gt; &#123;\n            System.out.println(&quot;map: &quot; + s);\n            return s.toUpperCase();\n        &#125;)\n        .forEach(System.out::println);\n\n&gt;&gt;&gt; flat map: [a, b]\nmap: a\nA\nmap: b\nB\nflat map: [c, d]\nmap: c\nC\nmap: d\nD\n\n5. Optional&lt;T&gt;\nOptional为空指针(NPE)问题提供了一种解决方案。它用Optional.empty()取代null，以避免null值的判断。\nJava 发布Optional的目的 是将其用作返回类型，从而表明方法可以返回空值。这显式地指出了可能的空指针问题。建议可能为null的返回值都使用Optional。\n类的内部不要使用Optional。\n集合内不要放置Optional对象，也不要用作map的key。\n不要直接调用 get()方法，应当先判断值是否存在或者调用orElseThrow()，orElse()或orElseGet()方法。\n\n6. Date&#x2F;Time API6.1 与原有api的对比新的API遵循ISO 8601标准，设计更加清晰，简化了日期和时间的处理。新API的设计借鉴了第三方库JodaTime。\n\n线程安全问题。新API中所有的日期时间都是不可变的，因此是线程安全的。Date和Calendar的值都是可以直接被修改的，可能出现潜在的线程安全问题。\n\n原有API有一些糟糕的设计，例如java.util.date年份从 1900 开始，月份从 0开始，日期从 1 开始。打印信息可读性较差。新的api则非常清晰。\nDate date &#x3D; new Date(2023, 2, 15);\nSystem.out.println(date);\n&gt;&gt;&gt; Thu Mar 15 00:00:00 CST 3923\n\nCalendar calendar &#x3D; Calendar.getInstance();\ncalendar.set(2023, 2, 15);\nSystem.out.println(calendar.getTime());\n&gt;&gt;&gt; Wed Mar 15 10:55:20 CST 2023\n\nvar localDateTime &#x3D; LocalDateTime.of(2023, 2, 15, 11, 13, 45);\nSystem.out.println(localDateTime);\n&gt;&gt;&gt; 2023-02-15T11:13:45\n\n新的api可以使用不同的日历系统。\n\n\n6.2 新的日期&#x2F;时间API\nInstant——代表一个时间点（timestamp）\nLocalDate——代表本地日期（年、月、日）\nLocalDateTime – 本地日期时间，时间为纳秒精度\nOffsetDateTime – 具有时区偏移的日期时间\nLocalTime – 具有纳秒精度且没有日期信息的时间\nZonedDateTime – 与OffsetDateTime类似，但包括时区 ID\nOffsetLocalTime – 与LocalTime类似，但具有时区偏移\nMonthDay – 月份和日期，没有年份或时间\nYearMonth – 月份和年份，没有日期或时间\nDuration——以秒、分钟和小时表示的时间量。具有纳秒精度\nPeriod——以天、月和年表示的时间量\n\n6.3 常用操作LocalDateTime可以认为是LocalDate+LocalTime，这里以LocalDateTime为例。\n\nLocalDateTime\n&#x2F;&#x2F; 指定日期时间\nvar localDateTime &#x3D; LocalDateTime.of(2023, 2, 15, 11, 13, 45);\n&#x2F;&#x2F; 当前日期时间\nvar now &#x3D; LocalDateTime.now();\n&#x2F;&#x2F; 获取年份\nint year &#x3D; now.getYear();\n&#x2F;&#x2F; 获取月份\nMonth month &#x3D; now.getMonth();\n&#x2F;&#x2F; 获取日期\nint day &#x3D; now.getDayOfMonth();\n&#x2F;&#x2F; 获取星期几\nDayOfWeek dayOfWeek &#x3D; now.getDayOfWeek();\n&#x2F;&#x2F;获取小时\nint hour &#x3D; now.getHour();\n&#x2F;&#x2F;获取分\nint minute &#x3D; now.getMinute();\n&#x2F;&#x2F;获取秒\nint second &#x3D; now.getSecond();\n&#x2F;&#x2F; 以上日期时间也可以通过枚举类ChronoField获取\nint month1 &#x3D; now.get(ChronoField.MONTH_OF_YEAR);\n\nInstant\n&#x2F;&#x2F; 当前时间点\nInstant instant &#x3D; Instant.now();\n&#x2F;&#x2F; 时间戳\nlong seconds &#x3D; instant.getEpochSecond();\nlong milliseconds &#x3D; instant.toEpochMilli();\n\n时间格式化\nvar datetimeFormatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\nString formatTime &#x3D; LocalDateTime.now().format(datetimeFormatter);\nvar parseTime &#x3D; LocalDateTime.parse(&quot;2023-02-11 11:20:12&quot;, datetimeFormatter);\n\n对日期时间的操作\n&#x2F;&#x2F; 可以用with*方法修改时间\nLocalDateTime happyTime &#x3D; LocalDateTime.now().withHour(18).withMinute(0).withSecond(0);\nSystem.out.println(happyTime);\n&gt;&gt;&gt; 2023-02-15T18:00:00.909434200\n&#x2F;&#x2F; 可以用TemporalAdjusters修改时间，比如获取当月最后一天\nLocalDateTime lastDayOfMonth &#x3D; LocalDateTime.now().with(TemporalAdjusters.lastDayOfMonth());\nSystem.out.println(lastDayOfMonth);\n&gt;&gt;&gt; 2023-02-28T13:50:46.909434200\n&#x2F;&#x2F; 获取下一个周五的时间\nLocalDateTime nextFriday &#x3D; LocalDateTime.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY));\nSystem.out.println(nextFriday);\n&gt;&gt;&gt; 2023-02-17T13:50:46.910434500\n&#x2F;&#x2F; 10天后，可以直接调用plusDays方法\nLocalDateTime afterTenDays &#x3D; LocalDateTime.now().plusDays(10);\nSystem.out.println(afterTenDays);\n&gt;&gt;&gt; 2023-02-20T13:55:20.574507300\n&#x2F;&#x2F; 10天前，除了minusDays，也可以手动指定单位\nLocalDateTime beforeTenDays &#x3D; LocalDateTime.now().minus(10, ChronoUnit.DAYS);\n\n参考资料：\n\nNew Features in Java 8\n\nJava SE 8 Optional, a pragmatic approach\n\n\n","slug":"Java8-17 新特性（一）","date":"2023-02-17T07:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"f2f9e3dbcdd8dee08b2c8bdbc160f6ea","title":"树型结构","content":"树型结构&#x2F;**\n\n * 获取组织机构树\n\n *\n\n * @author yuxuange\n\n * @Date 2021-02-03\n\n *&#x2F;\n\n@Component\n\npublic class TreeUtil &#123;\n\n    &#x2F;**\n\n     * 组织机构表，根节点CODE\n\n     *&#x2F;\n\n    private static final String TREE_ROOT_CODE &#x3D; &quot;0&quot;;\n\n &#x2F;**\n\n  * 标准版\n\n  *&#x2F;\n\n    public static List&lt;TreeVO&gt; getTree(List&lt;SysDept&gt; record) &#123;\n\n        List&lt;TreeVO&gt; treeList &#x3D; new LinkedList();\n\n        for (SysDept sysDept : record) &#123;\n\n            if (TREE_ROOT_CODE.equals(sysDept.getParentId())) &#123;\n\n                TreeVO treeVO &#x3D; new TreeVO();\n\n                treeVO.setId(sysDept.getCode());\n\n                treeVO.setTitle(sysDept.getName());\n\n                treeVO.setChildren(getChild(sysDept.getCode(), record));\n\n                treeList.add(treeVO);\n\n            &#125;\n\n        &#125;\n\n        return treeList;\n\n    &#125;\n\n    private static List&lt;TreeVO&gt; getChild(String code, List&lt;SysDept&gt; record) &#123;\n\n        List&lt;TreeVO&gt; childrenList &#x3D; new LinkedList();\n\n        for (SysDept sysDept : record) &#123;\n\n            if (code.equals(sysDept.getParentId())) &#123;\n\n                TreeVO treeVO &#x3D; new TreeVO();\n\n                treeVO.setId(sysDept.getCode());\n\n                treeVO.setTitle(sysDept.getName());\n\n                treeVO.setChildren(getChild(sysDept.getCode(), record));\n\n                childrenList.add(treeVO);\n\n            &#125;\n\n        &#125;\n\n        return childrenList;\n\n    &#125;\n\n &#x2F;**\n\n  * lamda表达式版\n\n  *&#x2F;\n\n    public static List&lt;TreeVO&gt; getTreeEX(List&lt;SysDept&gt; record)&#123;\n\n        return record.stream().filter(sysDept -&gt; &#123;return TREE_ROOT_CODE.equals(sysDept.getParentId());&#125;).map(sysDept -&gt; &#123;\n\n            TreeVO treeVO &#x3D; new TreeVO();\n\n            treeVO.setId(sysDept.getCode());\n\n            treeVO.setTitle(sysDept.getName());\n\n            treeVO.setChildren(getChildEX(sysDept.getCode(),record));\n\n            return treeVO;\n\n        &#125;).collect(Collectors.toList());\n\n    &#125;\n\n    private static List&lt;TreeVO&gt; getChildEX(String code,List&lt;SysDept&gt; record)&#123;\n\n        return record.stream().filter(sysDept -&gt; &#123;return code.equals(sysDept.getParentId());&#125;).map(sysDept -&gt; &#123;\n\n            TreeVO treeVO &#x3D; new TreeVO();\n\n            treeVO.setId(sysDept.getCode());\n\n            treeVO.setTitle(sysDept.getName());\n\n            treeVO.setChildren(getChildEX(sysDept.getCode(),record));\n\n            return treeVO;\n\n        &#125;).collect(Collectors.toList());\n\n    &#125;\n\n&#125;\n\n\ncsdn原文\n","slug":"树型结构","date":"2022-08-10T02:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"6543d025a348af299ba6e8174ff95a54","title":"Java创建List的四种方法","content":"Java创建List常用几种方式1、常规操作 new ArrayList&lt;&gt;() 创建\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(3);\n2、Arrays工具类创建\nList&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3);\nArrays.asList() 方法是 Arrays 的静态方法。这种方式构造的 List 是固定长度的，如果调用 add 方法增加新的元素时会报异常 java.lang.UnsupportedOperationException。这种方式仅适用于构造静态不变的 List。如果想要改变可以通过 ArrayLis t进行包装成动态。\nList&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3);\nlist &#x3D; new ArrayList&lt;&gt;(list);\nlist.add(4);\n3、Stream创建\nList&lt;Integer&gt; list &#x3D; Stream.of(1, 2, 3).collect(Collectors.toList());\n4、匿名内部类创建\nList&lt;Integer&gt; list&#x3D; new ArrayList() &#123;&#123;\n    add(1);\n    add(2);\n    add(3);\n&#125;&#125;;\n5、Hutool工具类创建\nList&lt;Integer&gt; list &#x3D; CollectionUtil.newArrayList(1, 2, 3);\n6、guava工具类创建\nimport com.google.common.collect.Lists;\n\nList&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3);\n7、JDK9 引入的Lists创建\nList&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3);\n8、JDK9引入 List.of (不可变)\nList&lt;Integer&gt; list &#x3D; List.of(1,2,3);\n","slug":"Java创建List的四种方法","date":"2022-06-22T02:03:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"3a82a96064298ae3557311afb39a2155","title":"linux 查看防火墙状态","content":"linux 查看防火墙状态1.查看防火墙状态\nsystemctl status firewalld\nfirewall-cmd –state #查看默认防火墙状态(关闭后显示notrunning，开启后显示running)\n2.查看防火墙是否开机启动\nsystemctl is-enabled firewalld\n3.关闭防火墙\nsystemctl stop firewalld\nsystemctl stop firewalld.service\nsystemctl status firewalld\n4.禁用防火墙(系统启动时不启动防火墙服务)\nsystemctl disable firewalld\nsystemctl disable firewalld.service\nsystemctl is-enabled firewalld\n","slug":"linux 查看防火墙状态","date":"2022-05-17T08:43:42.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"小海"},{"id":"4122a09df2e4f3d18921791a0dcc0507","title":"docker","content":"docker更新 yum我们会通过 yum 来安装 Docker, 所以首先更新 yum\nyum -y update\n安装docker接着就是安装 Docker\nyum install docker -y\n仅仅安装了还不行，还要启动\nsystemctl start docker.service\nsystemctl status docker.service\n设置docker开机自启\nsystemctl enable docker\n\n看到那个 active 就表示已经在运行啦以下是docker 的生命周期管理常用命令：\nsystemctl stop docker.service\nsystemctl start docker.service\nsystemctl restart docker.service\nsystemctl status docker.service\n镜像管理\n1. search 查看仓库里有些什么镜像\ndocker search tomcat\n会出来很多，那么到底应该用哪个呢？\n这时，就打开 hub.docker.com ，然后搜索 tomcat。 或者点击如下链接\nhttps://hub.docker.com/search?q=tomcat&amp;type=image\n可以看到更多的 tomcat了。\n而第一个，就是docker 官网提供的 tomcat了，一般就用他了吧。。。\n2. pull 拉取镜像\ntomcat 又有很多版本，到底选哪个呢？\n点击官网的 Tomcat 镜像，然后点击 tag，就发现又有很多版本\nhttps://hub.docker.com/_/tomcat?tab=tags那么就选一个自己当前需要的吧。 比如我要用 8.0 的话，那么就执行如下命令\ndocker pull tomcat:8.0\n\n不同镜像的用法不一样，在它的描述里都有详细讲解如何启动等等信息：\nhttps://hub.docker.com/_/tomcat?tab=description&amp;page=2\n比如这个8.0,按照官方指导启动办法：\ndocker run -it --rm -p 8888:8080 tomcat:8.0\n\n\n这个 –rm 表示如果容器已经存在了，自动删除容器\n最后访问： http:&#x2F;&#x2F;:8888 就可以正常访问了\n3. images 查看本地有些什么镜像\ndocker images\n4. rmi 删除本地镜像\ndocker images\ndocker rmi docker.io&#x2F;tomcat:8.0\n有时候为了调试，需要不厌其烦地删除镜像，下面这句话就会自动删除所有镜像啦\ndocker rmi $(docker images -q)\n5. 修改本地镜像名称 tag\n通过tag可以对镜像进行标记，如图所示，把 docker.io&#x2F;tomcat:8.0 标记成了docker.io&#x2F;mytomcat:8.0\ndocker tag docker.io&#x2F;tomcat:8.0 docker.io&#x2F;mytomcat:8.0\n\n这样 image_id&#x3D; “ef6a7c98d192” 的镜像，就有两个标记了，分别是docker.io&#x2F;tomcat:8.0docker.io&#x2F;mytomcat:8.0\n6. push , 把镜像提交到仓库\n注册账号\n仓库位于 hub.docker.com 上，为了提交新的镜像，肯定要有账号才行，所以第一步是注册账号。\n登录这里说的登录，不是在 hub.docker.com 网站上，而是在 docker 后台进行登录。执行命令：\ndocker login\n然后输入账号密码就行了。\n注意，账号不是邮箱地址哦\npush\n推送镜像到仓库首先镜像命名要符合 aaa&#x2F;bbb 这样的风格，即斜杠前面必须是你的账号名,冒号后为版本 如果镜像不是这个名字，可以通过 tag进行标记。 \ndocker push aaa&#x2F;bbb:8.0\n\n耗时多久，取决于你的镜像大小~\n容器管理\n\n运行 run\n\ndocker run --name some-mysql -v ~&#x2F;.halo&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql --privileged&#x3D;true -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw --net halo-net --restart&#x3D;unless-stopped -d mysql:8.0.27\n\n–name： 为容器指定一个名称\n\n\n-v ~&#x2F;.halo&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql 命令: 将宿主机的目录 ~&#x2F;.halo&#x2F;mysql 挂载到容器内部的目录 &#x2F;var&#x2F;lib&#x2F;mysql，默认情况下 MySQL 将向 ~&#x2F;.halo&#x2F;mysql 写入其数据文件。\n\n\n-p： 端口映射，格式为 主机(宿主)端口:容器端口 ，可在 application.yaml 配置。\n-e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw: 指定MySQL的登录密码为 my-secret-pw\n–net halo-net: 将该容器加入到 halo-net 网络,连接到 halo-net 网络的任何其他容器都可以访问 some-mysql容器上的所有端口。\n–restart： 建议设置为 unless-stopped，在 Docker 启动的时候自动启动 some-mysql 容器。\n-dit 是 -d -i -t 的缩写。 -d ，表示 detach，即在后台运行。 -i 表示提供交互接口，这样才可以通过 docker 和 跑起来的操作系统交互。 -t 表示提供一个 tty (伪终端)，与 -i 配合就可以通过 ssh 工具连接到 这个容器里面去了\n–privileged 启动容器的时候，把权限带进去。 这样才可以在容器里进行完整的操作\n\n\n\n\n\n\n\n\n\n\nCentos7的安全Selinux禁止了一些安全权限，导致挂载信息时出出现权限不足，run命令行添加 –privileged&#x3D;true\n\n进入 exec attach\n\n  some-mysql 为 MySQL 实例的容器名称\ndocker exec -it some-mysql &#x2F;bin&#x2F;bash\n\n\n生命周期管理， 暂停，恢复，停止，启动 pause, unpause, stop, start\n\n暂停：pause\n恢复：unpause\n停止：stop\n开始：start\n\nps 查看所有的容器查询所有的容器docker ps\n查询查询 run 状态的和 pause 状态的， stop状态的就不会查询出来了docker ps -a\n检查某个具体的容器  inspect\n\n检查这个容器里的各项信息，\ndocker inspect some-mysql\n\nrm 删除容器\n\n删除容器，与删除镜像 rmi 命令遥相呼应。。。。\ndocker rm some-mysql\n\n在运行中的 容器是不能删除的，要先 stop ,然后再删除。\n\ncommit，对容器做了修改后，把改动后的容器，再次转换为镜像\ncommit 很有意思了，因为它的作用就是把一个活生生的容器，再转换为镜像。\n使用办法：\n\n\ndocker commit some-mysql new-mysql:now\n","slug":"docker","date":"2022-05-12T07:33:42.000Z","categories_index":"docker","tags_index":"docker","author_index":"小海"},{"id":"c3fe4d98af02bf9a9f9237331aef4bd4","title":"win cmd卸载命令","content":"win cmd卸载命令\n在窗口中输入 ：wmic 然后回车\n输入product list 回车让然后稍微等待一会\n找到需要卸载程序的IdentfyingNUmber\n输入exit 退出wmic\n输入msiexec&#x2F;x + 刚才复制的Number\n确定即可\n\n","slug":"win cmd卸载命令","date":"2022-05-07T02:42:42.000Z","categories_index":"windows","tags_index":"windows","author_index":"小海"}]