[{"id":"fc8441281cafc01b53d6231870878c78","title":"SpringBoot循环依赖问题","content":"SpringBoot 循环依赖问题Java中的循环依赖问题指的是两个或多个类之间相互依赖，形成了一个环路，导致编译器无法确定某个类的具体实现。例如，类A依赖于类B，而类B又依赖于类A，这样就形成了一个循环依赖。这种问题通常会导致编译错误或运行时错误，因此需要避免出现循环依赖。以下是几种解决循环依赖问题的方法：\n\n重构代码：将相互依赖的类进行合理的划分和重构，消除循环依赖。\n\n使用接口：将相互依赖的类抽象成接口，然后再进行依赖注入，这样可以避免循环依赖。\n\n使用延迟加载：将依赖的类在需要使用时再进行加载，而不是在类初始化时就加载，这样可以避免循环依赖。\n\n使用中介类：引入一个中介类，将相互依赖的类都注入到中介类中，然后再将中介类注入到需要使用的类中，这样可以避免循环依赖。\n\n\n@Lazy注解   @Lazy注解可以延迟加载一个bean，即在需要使用该bean时才会被加载。\n@Lazy\n@Autowired\nprivate  TestService testService;\n注意： 使用lombok提供的注解@RequiredArgsConstructor延迟加载会失效，取消final修饰用@Autowired\n","slug":"SpringBoot循环依赖问题","date":"2023-03-17T06:43:31.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"4d178542e742a642ab21284220759956","title":"hexo搭建","content":"hexo搭建\n什么是hexo？   Hexo是一个基于Node.js的静态博客生成器，可以将Markdown格式的文本转换成静态网页的形式。 它支持大量的主题和插件，可以方便地定制自己的博客主题和功能。   Hexo还支持多种发布方式， 包括将生成的静态网页部署到Github Pages、Heroku等云服务上，也可以通过FTP、SSH等方式将博客发布到自己的服务器上。   Hexo是一个非常流行的静态博客生成器，被广泛用于个人博客、技术博客等各种领域。\n安装Hexo的步骤如下：1.安装Node.jsHexo是基于Node.js的，因此需要先安装Node.js。可以在Node.js官网下载对应的安装包进行安装。\n2.安装GitGit是一个版本控制工具，Hexo在安装和部署时需要使用到Git。可以在Git官网下载对应的安装包进行安装。\n3.安装Hexo在命令行中执行以下命令来安装Hexo：\nnpm install -g hexo-cli\n\n4.初始化Hexo博客在命令行中执行以下命令来初始化一个Hexo博客：\nhexo init &lt;folder&gt;\ncd &lt;folder&gt;\nnpm install\n\n其中，folder为博客的文件夹名称，可以自定义。\n5.运行Hexo博客   在命令行中执行以下命令来启动Hexo博客：\nhexo server\n\n然后在浏览器中访问 http://localhost:4000 即可查看Hexo博客。\n\n\n\n\n\n\n\n\n\n详细安装教程，请访问官网 https://hexo.io/zh-cn/\n主题安装 有了博客，当然要简单装饰一下了，安装一个主题，官网自己挑选一个用就可以，当前我用的是 Hexo Aurora 就讲一下这个简单实用。\n安装Hexo Aurora主题的步骤如下：步骤 1 - 安装主题包在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\nnpm install hexo-theme-aurora --save\n步骤 2 - 主题设置 进入Hexo博客的配置文件 _config.yml,找到theme修改为aurora：\ntheme: aurora\n步骤 3 - 设置 permalink进入Hexo博客的配置文件 _config.yml，修改 permalink 参数为 &#x2F;post&#x2F;:title.html\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as &#39;https:&#x2F;&#x2F;username.github.io&#x2F;project&#39;\nurl: https:&#x2F;&#x2F;xiaohai-store.github.io\npermalink: &#x2F;post&#x2F;:title.html\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks\n  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks\n步骤 4 - 设置代码高亮最后主题是使用 Prismjs 来实现代码高亮显示，但 Hexo 默认是使用 highlightjs，因此你需要更改 Hexo 配置来使用 Prismjs:\n\n把 highlight 的启用改为false\n把 prismjs 的启用改为true\n把 prismjs 下的 preprocess 改为 falsehighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: false\n  line_number: true\n  tab_replace: &#39;&#39;\n\n\n\n\n\n\n\n\n\n详细安装教程，请访问官网 https://aurora.tridiamond.tech/zh/\n\n\n快速入门使用创建新文章$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\n运行服务$ hexo server\n\nMore info: Server\n生成静态文件$ hexo generate\n\nMore info: Generating\n部署到远程站点$ hexo deploy\n\nMore info: Deployment\n遇到的问题问题1：文章时间问题需要在md最开始添加一下数据文件，可参考模板目录scaffolds,详细可见官方文档 https://hexo.io/zh-cn/docs/front-matter\n---\ntitle: 标题\ndate: 建立日期\n---\n问题2：分类标签不展示需要完善tags 和 categories，封面添加cover属性，详细可见官方文档 https://hexo.io/zh-cn/docs/front-matter\n---\ntitle: 标题\ndate: 建立日期\ntags: 标签\ncategories: 分类\ncover:  主题封面\n---\n问题3：设置logo不生效 需要将图标放置source文件下才生效\n问题4：社交链接图标 请注意图标名称为 icon 不是 icons 仔细阅读官方文档,搞了大半天是名字问题\n问题5 gitalk评论 中文不要设置为 cn 请设置为zn-CN\nlanguage: zh-CN\n 评论区会展示多个联系人，是因为作者配置文件的问题，到作者主题包下去掉配置文件\n问题6 github部署问题​    我这边采用一键部署\n\n在 GitHub 上创建一个新的仓库，用于存储 Hexo 生成的静态文件。\n\n在本地安装 Hexo，并在 Hexo 根目录下执行以下命令\n\n\nnpm install hexo-deployer-git --save\n​\t这个命令会安装 Hexo 的 Git 部署插件，用于将博客发布到 GitHub 上。\n\n在 Hexo 根目录下的 _config.yml 文件中配置 Git 部署插件，例如：\n\ndeploy:\n   type: git\n   repo: https:&#x2F;&#x2F;key@github.com&#x2F;xiaohai-store&#x2F;xiaohai-store.github.io.git\n   branch: gh-pages\n注意： key 为github的秘钥\n\n生成静态文件并将其部署到 GitHub 上。在 Hexo 根目录下执行以下命令：\n\nhexo generate\nhexo deploy\n\n​\t这个命令会将 Hexo 生成的静态文件部署到指定的 GitHub 仓库中。\n\n确认发布成功。访问你的 GitHub Pages 地址，检查博客是否已经成功发布到新的仓库中。\n\n","slug":"blog/hexo搭建/hexo搭建","date":"2023-03-16T01:43:19.000Z","categories_index":"blog","tags_index":"blog","author_index":"小海"},{"id":"44f3816acae6092110e3c35d6f574b7f","title":"OpenAPI规范和SpringDoc使用","content":"OpenAPI规范和SpringDoc使用\n1. 简介OpenAPI规范(OAS)，以前称为Swagger 规范，是一种机器可读的接口定义语言的规范，用于描述、生成、使用和可视化RESTful Web 服务。它以前是Swagger框架的一部分，在 2016 年成为一个单独的项目，由 OpenAPI Initiative 监督，OpenAPI Initiative 是Linux 基金会的一个开源协作项目。 Swagger 和其他一些工具可以从接口文件生成代码、文档和测试用例。\n2. 规范2.1 文档版本OpenAPI 规范使用语义版本控制 2.0.0 (semver) 进行版本控制，并遵循 semver 规范。\n2.2 文档格式OpenAPI文档本身是一个JSON对象，可以用JSON或YAML格式表示。\n字段名称区分大小写。\n2.3 数据类型\nOAS的原始数据类型基于JSON Schema Specification Wright Draft 00，并做了一定的扩展。\n\n原始类型有一个可选的修饰属性：format。规范指定了一部分format类型，但也可以对其进行扩展，比如使用email，uuid等，只要能被工具解析即可。\n\nOAS定义的格式如下：\n\n\n\ntype\nformat\n备注\n\n\n\ninteger\nint32\n32 位有符号 (byte, short, int)\n\n\ninteger\nint64\n64 位有符号（long类型）\n\n\nnumber\nfloat\n\n\n\nnumber\ndouble\n\n\n\nstring\n\n\n\n\nstring\nbyte\nbase64编码的字符\n\n\nstring\nbinary\n任何八位字节序列\n\n\nboolean\n\n\n\n\nstring\ndate\n由RFC3339定义定义的full-date\n\n\nstring\ndate-time\n由RFC3339定义的date-time\n\n\nstring\npassword\n提示界面不应明文输入\n\n\n\n\n2.4 富文本格式规范中的**description**字段支持Markdown格式。\n3. 框架3.1 固定字段\n\n\n字段名\n类型\n是否必需\n描述\n\n\n\nopenapi\nstring\n是\nOpenAPI规范的版本号。\n\n\ninfo\nInfo 对象\n是\nAPI相关的元数据。\n\n\nservers\n[Server 对象]\n否\nServer对象的数组， 提供到服务器的连接信息\n\n\npaths\nPaths 对象\n是\nAPI的可用路径和操作。\n\n\ncomponents\nComponent 对象\n否\n一个包含多种结构的组件\n\n\nsecurity\n[Security Requirement 对象]\n否\n可以在 API 中使用哪些安全机制的声明\n\n\ntags\n[Tag 对象]\n否\n带有附加元数据的标签列表，每个标签名称必须是唯一的\n\n\nexternalDocs\nExternal Documentation 对象\n否\n额外的外部文档。\n\n\n\n\n\n3.2 Paths 对象Paths:\n  PathItem:\n    Operation:     # @Operation注解，http方法根据 @GetMapping @PostMapping等注解判断\n      - summary           # @Operation(summary &#x3D; &quot;保存用户信息&quot;, description &#x3D; &quot;保存用户信息&quot;) 对应summary\n      - description       # @Operation(summary &#x3D; &quot;保存用户信息&quot;, description &#x3D; &quot;保存用户信息&quot;) 对应description\n      - tags              # 指定tag\n      - parameters        # url参数，对应@Parameter注解，如果参数放在了类中，需要在类上添加@ParameterObject注解\n      - requestBody       # requestBody，对应@RequestBody注解的类\n      - responses         # responseBody，controller方法的返回对象\n\n3.3 Operation对象\n描述路径上的单个API操作。包括get, post, delete, put, options等\n\n常用字段\n\n\n\n字段名\n类型\n描述\n\n\n\nsummary\nstring\n该操作的作用的简短摘要。\n\n\ndescription\nstring\n对操作行为的详细解释。支持markdown语法\n\n\nparameters\n[Parameter对象 或 Reference对象]\n适用于此操作的参数列表\n\n\nrequestBody\nRequest Body对象 或 Reference对象\n适用于此操作的请求正文\n\n\nresponses\nResponses 对象\n执行此操作返回的可能响应列表\n\n\ntags\n[string]\nAPI 文档控制的标签列表\n\n\n\n配置方式\n@Operation(summary &#x3D; &quot;获取用户列表&quot;,\n        description &#x3D; &quot;&quot;&quot;\n                &lt;b&gt;获取*用户*列表&lt;&#x2F;b&gt;\n                - username: 用户名\n                - status: 状态\n                &quot;&quot;&quot;\n)\n@GetMapping(&quot;users&quot;)\npublic List&lt;UserDTO&gt; getUsers(@ParameterObject UserQuery query) &#123;\n    var userDTO &#x3D; getUser();\n    return List.of(userDTO);\n&#125;\n\n3.4 Parameter对象\n描述单个操作的参数，通过in字段定义了4种不同的参数位置\n\npath - URL中的参数。例如items/&#123;itemId&#125;，itemId是路径参数\n\nquery - 附加在URL后的参数。例如items?id=1，请求参数为id\n\nheader - 自定义header中参数\n\ncookie - 通过cookie传的参数\n\n\n\n常用字段：\n\n\n\n字段名\n类型\n描述\n\n\n\nname\nstring\n字段名，用默认值，不要做任何修改\n\n\nin\nstring\n参数的位置，包括path, query, header, cookie4种，不需要设置\n\n\ndescription\nstring\n参数的描述，支持markdown\n\n\nrequired\nboolean\n参数是否必需。path中的参数必须设置成true\n\n\ndeprecated\nboolean\n参数是否废弃\n\n\nschema\nSchema对象\n定义用于参数的类型的模式。\n\n\nexample\nAny\n参数示例\n\n\n\n配置方式\n@Parameter(\n        description &#x3D; &quot;&quot;&quot;\n                状态\n                - 1: 启用\n                - 2: 禁用\n                - 3: 锁定\n                &quot;&quot;&quot;,\n        required &#x3D; true,\n        schema &#x3D; @Schema(allowableValues &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, type &#x3D; &quot;integer&quot;))\nprivate Byte status;\n\n3.5 Request Body 对象请求体，添加@RequestBody即可\n3.6 Response 对象方法的返回值\n3.7 Schema对象\nSchema对象定义输入和输出数据类型。这些类型可以是对象，也可以是基础类型和数组\n\n常用的字段有title, maxLength, minLength, maximum, minimum, pattern, enum 等\n\n使用方式：一般是在DTO、VO的字段上使用\n@Schema(title &#x3D; &quot;用户名&quot;)\nprivate String username;\n\n3.8 Tag对象\n使用Tag对象添加元数据，作用于Operation对象上\n\n使用方法\n@Tag(name &#x3D; &quot;user&quot;, description &#x3D; &quot;涉及用户的操作，包括增删改查等操作&quot;)\n@RestController\npublic class UserController &#123;\n\n3.9 扩展扩展属性需要以x-开头。\n以openapi-generator为例，该工具扩展了enum属性，添加了x-enum-varnames等字段，用来表示enum的值。我们可以通过@Extention注解来实现属性扩展。\n@Schema(title &#x3D; &quot;状态&quot;,\n            type &#x3D; &quot;integer&quot;,\n            allowableValues &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;,\n            extensions &#x3D; @Extension(\n                    properties &#x3D; @ExtensionProperty(\n                            name &#x3D; &quot;enum-varnames&quot;,\n                            value &#x3D; &quot;&quot;&quot;\n                                    [&quot;启用&quot;,&quot;禁用&quot;,&quot;锁定&quot;]\n                                    &quot;&quot;&quot;,\n                            parseValue &#x3D; true\n                    )\n            ))\nprivate Byte status;\n\n\n\n4. SpringDoc 使用\nController类上使用@Tag注解，方法上使用@Operation注解\n\n@Tag注解的name可以不配置，默认是类名(短横线连接)，如果配置，则必须使用英文\n\n需要区分请求参数和RequestBody。请求参数字段使用@Parameter注解，RequestBody中的字段使用@Schema注解\n\n请求参数数量超过2个时，应将封装在一个Query类中，并在该类上使用@ParameterObject注解，类的字段使用@Parameter注解\n\nByte，Short类型，SpringDoc会识别为string类型，应将其手动设置成integer类型，设置方法如下\n&#x2F;&#x2F; schema的设置方式\n@Schema(title &#x3D; &quot;状态&quot;,type &#x3D; &quot;integer&quot;)\nprivate Byte status;\n&#x2F;&#x2F; parameter的设置方式\n@Parameter(description &#x3D; &quot;状态&quot;, schema &#x3D; @Schema(type &#x3D; &quot;integer&quot;))\nprivate Byte status;\n\n枚举类需要通过@Schema注解的allowableValues参数进行配置。openapi-generator工具使用了扩展字段x-enum-varnames来描述枚举对应的值，扩展字段可以通过@Extension注解来实现，示例如下\n@Schema(title &#x3D; &quot;状态&quot;,\n        type &#x3D; &quot;integer&quot;,\n        allowableValues &#x3D; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &#x2F;&#x2F; 枚举值\n        extensions &#x3D; @Extension(\n                properties &#x3D; @ExtensionProperty(\n                        name &#x3D; &quot;enum-varnames&quot;,  &#x2F;&#x2F; 扩展字段的字段名，会自动添加&#96;x-&#96;前缀\n                        value &#x3D; &quot;&quot;&quot;\n                                [&quot;启用&quot;,&quot;禁用&quot;,&quot;锁定&quot;]\n                                &quot;&quot;&quot;, &#x2F;&#x2F; 固定设置为json array格式，array中的每个值与allowableValues中的枚举值对应\n                        parseValue &#x3D; true &#x2F;&#x2F; 设置true，可将value解析成array\n                )\n        ))\nprivate Byte status;\n\nSpringDoc支持常用的JSR-303注解，如*@NotNull*, @NotBlank, @Size, @Min, @Max 等\n\n注意书写规范，方法名、参数名、成员变量、局部变量必须使用lowerCamelCase风格，类名使用 UpperCamelCase 风格。\n\n\n附录\n参考\n\nDocumenting a Spring REST API Using OpenAPI 3.0\nOpenAPI Specification\nopenapi-generator文档\nSpringdoc文档\n\n\n一份完整的OpenApi文档\n\n\n&#123;\n    &quot;openapi&quot;: &quot;3.0.1&quot;,\n    &quot;info&quot;: &#123;\n        &quot;title&quot;: &quot;openapi示例&quot;,\n        &quot;description&quot;: &quot;用于演示Springdoc的用法&quot;,\n        &quot;version&quot;: &quot;1.0.0&quot;\n    &#125;,\n    &quot;servers&quot;: [\n        &#123;\n            &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&quot;,\n            &quot;description&quot;: &quot;Generated server url&quot;\n        &#125;\n    ],\n    &quot;security&quot;: [\n        &#123;\n            &quot;authentication&quot;: []\n        &#125;\n    ],\n    &quot;tags&quot;: [\n        &#123;\n            &quot;name&quot;: &quot;role&quot;,\n            &quot;description&quot;: &quot;涉及用户的操作，包括增删改查等操作&quot;\n        &#125;,\n        &#123;\n            &quot;name&quot;: &quot;user&quot;,\n            &quot;description&quot;: &quot;涉及用户的操作，包括增删改查等操作&quot;\n        &#125;\n    ],\n    &quot;paths&quot;: &#123;\n        &quot;&#x2F;users&quot;: &#123;\n            &quot;get&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;user&quot;\n                ],\n                &quot;summary&quot;: &quot;获取用户列表&quot;,\n                &quot;description&quot;: &quot;&lt;b&gt;获取*用户*列表&lt;&#x2F;b&gt;\\n- username: 用户名\\n- status: 状态\\n&quot;,\n                &quot;operationId&quot;: &quot;getUsers&quot;,\n                &quot;parameters&quot;: [\n                    &#123;\n                        &quot;name&quot;: &quot;username&quot;,\n                        &quot;in&quot;: &quot;query&quot;,\n                        &quot;description&quot;: &quot;用户名&quot;,\n                        &quot;required&quot;: false,\n                        &quot;schema&quot;: &#123;\n                            &quot;type&quot;: &quot;string&quot;\n                        &#125;\n                    &#125;,\n                    &#123;\n                        &quot;name&quot;: &quot;status&quot;,\n                        &quot;in&quot;: &quot;query&quot;,\n                        &quot;description&quot;: &quot;状态\\n- 1: 启用\\n- 2: 禁用\\n- 3: 锁定\\n&quot;,\n                        &quot;required&quot;: false,\n                        &quot;schema&quot;: &#123;\n                            &quot;maximum&quot;: 3,\n                            &quot;minimum&quot;: 1,\n                            &quot;type&quot;: &quot;integer&quot;,\n                            &quot;enum&quot;: [\n                                &quot;1&quot;,\n                                &quot;2&quot;,\n                                &quot;3&quot;\n                            ]\n                        &#125;\n                    &#125;\n                ],\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;type&quot;: &quot;array&quot;,\n                                    &quot;items&quot;: &#123;\n                                        &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserDTO&quot;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;,\n            &quot;post&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;user&quot;\n                ],\n                &quot;summary&quot;: &quot;保存用户信息&quot;,\n                &quot;operationId&quot;: &quot;saveUser&quot;,\n                &quot;requestBody&quot;: &#123;\n                    &quot;content&quot;: &#123;\n                        &quot;application&#x2F;json&quot;: &#123;\n                            &quot;schema&quot;: &#123;\n                                &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserVO&quot;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;required&quot;: true\n                &#125;,\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserDTO&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\n        &quot;&#x2F;users&#x2F;&#123;id&#125;&quot;: &#123;\n            &quot;get&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;user&quot;\n                ],\n                &quot;summary&quot;: &quot;获取单个用户信息&quot;,\n                &quot;operationId&quot;: &quot;getUser&quot;,\n                &quot;parameters&quot;: [\n                    &#123;\n                        &quot;name&quot;: &quot;id&quot;,\n                        &quot;in&quot;: &quot;path&quot;,\n                        &quot;description&quot;: &quot;用户id&quot;,\n                        &quot;required&quot;: true,\n                        &quot;schema&quot;: &#123;\n                            &quot;type&quot;: &quot;string&quot;\n                        &#125;\n                    &#125;\n                ],\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;UserDTO&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\n        &quot;&#x2F;roles&quot;: &#123;\n            &quot;get&quot;: &#123;\n                &quot;tags&quot;: [\n                    &quot;role&quot;\n                ],\n                &quot;operationId&quot;: &quot;getRoles&quot;,\n                &quot;responses&quot;: &#123;\n                    &quot;200&quot;: &#123;\n                        &quot;description&quot;: &quot;OK&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;type&quot;: &quot;array&quot;,\n                                    &quot;items&quot;: &#123;\n                                        &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;RoleDTO&quot;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;400&quot;: &#123;\n                        &quot;description&quot;: &quot;Bad Request&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;,\n                    &quot;500&quot;: &#123;\n                        &quot;description&quot;: &quot;Internal Server Error&quot;,\n                        &quot;content&quot;: &#123;\n                            &quot;*&#x2F;*&quot;: &#123;\n                                &quot;schema&quot;: &#123;\n                                    &quot;$ref&quot;: &quot;#&#x2F;components&#x2F;schemas&#x2F;ResponseError&quot;\n                                &#125;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;,\n    &quot;components&quot;: &#123;\n        &quot;schemas&quot;: &#123;\n            &quot;ResponseError&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;code&quot;: &#123;\n                        &quot;title&quot;: &quot;异常代码&quot;,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;400&quot;\n                    &#125;,\n                    &quot;message&quot;: &#123;\n                        &quot;title&quot;: &quot;异常信息&quot;,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;该参数不能为空&quot;\n                    &#125;,\n                    &quot;errors&quot;: &#123;\n                        &quot;type&quot;: &quot;object&quot;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;,\n            &quot;UserVO&quot;: &#123;\n                &quot;required&quot;: [\n                    &quot;phone&quot;,\n                    &quot;username&quot;\n                ],\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;username&quot;: &#123;\n                        &quot;title&quot;: &quot;用户名&quot;,\n                        &quot;maxLength&quot;: 20,\n                        &quot;minLength&quot;: 5,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;admin&quot;\n                    &#125;,\n                    &quot;nickname&quot;: &#123;\n                        &quot;title&quot;: &quot;昵称&quot;,\n                        &quot;maxLength&quot;: 20,\n                        &quot;minLength&quot;: 0,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;example&quot;: &quot;dongting&quot;\n                    &#125;,\n                    &quot;phone&quot;: &#123;\n                        &quot;title&quot;: &quot;手机号&quot;,\n                        &quot;pattern&quot;: &quot;^1[3-9][0-9]&#123;9&#125;$&quot;,\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;,\n            &quot;UserDTO&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;id&quot;: &#123;\n                        &quot;title&quot;: &quot;主键&quot;,\n                        &quot;type&quot;: &quot;integer&quot;,\n                        &quot;format&quot;: &quot;int64&quot;\n                    &#125;,\n                    &quot;username&quot;: &#123;\n                        &quot;title&quot;: &quot;用户名&quot;,\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;,\n                    &quot;nickname&quot;: &#123;\n                        &quot;title&quot;: &quot;昵称&quot;,\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;,\n                    &quot;avatar&quot;: &#123;\n                        &quot;title&quot;: &quot;头像&quot;,\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;用户头像，base64&quot;,\n                        &quot;format&quot;: &quot;byte&quot;\n                    &#125;,\n                    &quot;status&quot;: &#123;\n                        &quot;title&quot;: &quot;状态&quot;,\n                        &quot;type&quot;: &quot;integer&quot;,\n                        &quot;format&quot;: &quot;int32&quot;,\n                        &quot;enum&quot;: [\n                            1,\n                            2,\n                            3\n                        ],\n                        &quot;x-enum-varnames&quot;: [\n                            &quot;启用&quot;,\n                            &quot;禁用&quot;,\n                            &quot;锁定&quot;\n                        ]\n                    &#125;,\n                    &quot;roles&quot;: &#123;\n                        &quot;title&quot;: &quot;角色&quot;,\n                        &quot;type&quot;: &quot;array&quot;,\n                        &quot;items&quot;: &#123;\n                            &quot;title&quot;: &quot;角色&quot;,\n                            &quot;type&quot;: &quot;string&quot;\n                        &#125;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;,\n            &quot;RoleDTO&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;name&quot;: &#123;\n                        &quot;type&quot;: &quot;string&quot;\n                    &#125;\n                &#125;,\n                &quot;description&quot;: &quot;&quot;\n            &#125;\n        &#125;,\n        &quot;securitySchemes&quot;: &#123;\n            &quot;authentication&quot;: &#123;\n                &quot;type&quot;: &quot;apiKey&quot;,\n                &quot;name&quot;: &quot;authentication&quot;,\n                &quot;in&quot;: &quot;header&quot;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n","slug":"OpenAPI规范和SpringDoc使用","date":"2023-03-10T03:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"d459146c27d3881c39d30204014457f4","title":"nvm for windows 下载、安装及使用","content":"nvm for windows 下载、安装及使用\nnvm是node版本管理工具，可以运行在多种操作系统上。这里主要记录一下在windows系统的安装和使用。\n下载NVM for Windows 下载地址： github.com&#x2F;coreybutler…\n 只需点击第三个，下载安装包，下载之后点击安装，无需配置就可以使用，十分方便。\n简单说明：\n\nnvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置\nnvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。\nSource code(zip)：zip压缩的源码\nSourc code(tar.gz)：tar.gz的源码，一般用于*nix系统\n\n安装\n第一安装目录：这里没有使用默认的安装目录，修改安装目录为 D:\\nvm\\ ；读者可自行决定安装目录\n第二安装目录：添加 node.js 的安装目录 这里用 “添加 node.js 的安装目录” 的说法其实不太准确，准确的说法应该是配置 node.js 的安装目录；默认会使用 C:\\Program Files\\nodejs 目录，C:\\Program Files\\nodejs 目录也是 node.js 默认的安装目录；如果读者在安装 nvm 前就已经安装了 node.js，且修改了 node.js 的安装目录，那么此处的目录要修改为 node.js 的安装目录；如果读者在安装 nvm 前没有安装 node.js，那么此处的目录可自行定义\n第三点击安装，在安装过程中会弹出：由于已经安装了 node，所以此时提示“你希望nvm管理已经安装的 node 版本吗”，点击 是待安装完成后测试是否安装成功\n\nnvm -v\n复制代码\n\n\n命令使用nvm for windows是一个命令行工具，在控制台输入nvm,就可以看到它的命令用法。基本命令有：\n\nnvm arch [32|64] ： 显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构。\nnvm install  [arch]： 该可以是node.js版本或最新稳定版本latest。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为all以安装32和64位版本。在命令后面添加–insecure ，可以绕过远端下载服务器的SSL验证。\nnvm list [available]： 列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表。这个命令可以简写为nvm ls [available]。\nnvm on： 启用node.js版本管理。\nnvm off： 禁用node.js版本管理(不卸载任何东西)\nnvm proxy [url]： 设置用于下载的代理。留[url]空白，以查看当前的代理。设置[url]为none删除代理。\nnvm node_mirror [url]：设置node镜像，默认为nodejs.org&#x2F;dist&#x2F;.。建议设置…\nnvm npm_mirror [url]：设置npm镜像，默认为github.com&#x2F;npm&#x2F;npm&#x2F;arc…\nnvm uninstall ： 卸载指定版本的nodejs。\nnvm use [version] [arch]： 切换到使用指定的nodejs版本。可以指定32&#x2F;64位[arch]。nvm use 将继续使用所选版本，但根据提供的值切换到32&#x2F;64位模式的\nnvm root [path]： 设置 nvm 存储node.js不同版本的目录 ,如果未设置，将使用当前目录。\nnvm version： 显示当前运行的nvm版本，可以简写为nvm v 常用命令：\nnvm ls 查看已经安装的所有nodejs版本\\\nnvm install 版本号，可安装指定版本的nodejs\\\nnvm use 版本号，即可切换到指定版本\\\nnvm uninstall 版本号，卸载指定版本\n\n注意：在使用nvm-window 时得环境变量的配置，尤其Path 是否正确。\n作者：沐溪兮链接：https://juejin.cn/post/7074108351524634655\n","slug":"nvm for windows 下载、安装及使用","date":"2023-02-26T10:19:42.000Z","categories_index":"web","tags_index":"web","author_index":"小海"},{"id":"cfd6516cec60dd52fbe0026aa3ac0713","title":"Java8-17 新特性（二）","content":"Java8-17 新特性（二）Java91. Java平台模块系统(JPMS)1.1 模块\n模块是一个命名的、自描述的代码和数据集合(A module is a named, self-describing collection of code and data.)。它是一组包含类型的包(package)的集合，也包括其他一些静态资源。\n模块可以理解为package的上级容器，可以控制一个package是否对外暴露(exports)，从而实现更精细化的访问控制。\n\n1.2 模块化的使用方式如何把一个普通项目变成模块化项目？\n\n首先添加一个模块描述符(module-info.java)文件，并定义模块名称：\nmodule insoundai.api &#123;\n&#125;\n\n以上我们定义了一个名为insoundai.api的模块。\n\n然后暴露(exports)我们需要让别人访问的包(package)\nmodule insoundai.api &#123;\n    exports com.insoundai.api;\n&#125;\n\n这样别的模块引用insoundai.api模块时，就可以调用com.insoundai.api包下面的类或其他资源了。\n\n如果我们需要引用其他模块的类，必须先用requires导入这个模块\nmodule insoundai.api &#123;\n    requires insoundai.util;\n\n    exports com.insoundai.api;\n&#125;\n\n有时候，我们希望调用本模块时，被我们引用的模块也能暴露出去。比如我们暴露某个Service，这个Service用到的实体类却是别的模块的，那我们希望Service跟这个实体类一起暴露出去。这时我们可以用requires transitive，来表示这个模块的引用是可以被传递的。\nmodule insoundai.api &#123;\n    requires transitive insoundai.persistence;\n    requires insoundai.util;\n\n    exports com.insoundai.api;\n&#125;\n\n当别的模块引用insoundai.api模块时，insoundai.persistence模块会同时被引入。\n\n有的模块只需要编译时存在，比如lombok，我们可以用requires static来声明：\nmodule insoundai.persistence &#123;\n    requires static lombok;\n    exports com.insoundai.persistence.entity;\n&#125;\n\nopens用于声明仅运行时可访问的包，这些包的内容可以通过反射获取。这对Spring项目非常有用，我们声明的Spring Bean都需要通过这种方式让spring调用到。\nmodule insoundai.api &#123;\n    requires transitive insoundai.persistence;\n    requires insoundai.util;\n    requires spring.context;\n\n    opens com.insoundai.api.impl to spring.beans;\n\n    exports com.insoundai.api;\n&#125;\n\n1.3 模块化的好处1.3.1. 可靠性配置通过显式地声明组件之间的依赖关系，取代脆弱、易出错的类路径机制。\n1.3.2 强封装允许组件声明它的哪些公共类型可以被其他组件访问，哪些不能。\n1.4 与Maven多模块的区别\nMaven的模块都可以作为单独的项目存在，都有自己的pom文件，可以打成单独的jar包。Maven多模块一般只用于复杂的项目，是基于某种缘由对项目的拆分。\nJMPS关注的是项目内包的管理，用来控制项目内的包是否能被外部访问到。\n\n2. JShell\nJShell是一个交互式工具(REPL)。它在输入声明、语句和表达式时计算它们，并立即显示结果。该工具从命令行运行。\n$ jshell\njshell&gt; System.out.println(&quot;hello world&quot;);\nhello world\n\njshell&gt; int x &#x3D; 0;\nx &#x3D;&#x3D;&gt; 0\njshell&gt; for (int i &#x3D; 0;i &lt; 10;i++) &#123;\n   ...&gt;     x +&#x3D; i;\n   ...&gt; &#125;\njshell&gt; System.out.println(x);\n45\n\n3. 快速创建不可变集合\n增加了List.of()、Set.of()、Map.of() 和 Map.ofEntries()等工厂方法来创建不可变集合\nList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nMap.of(&quot;k1&quot;, &quot;val1&quot;, &quot;k2&quot;, &quot;val2&quot;);\n\nJava10局部变量类型推断\nJava10提供了局部变量的类型推断。局部变量初始化时，可以用var替代显式的变量类型声明。\nvar text &#x3D; &quot;Hello World!&quot;;\n\nvar不是关键字，而是保留的类型名称。这保证了var作为函数名或变量名的向后兼容性。\n\n变量的类型信息会在编译时通过等号右侧信息推断出来，因此var的使用不会对Java运行时的性能产生影响，也不会使Java变成动态语言。\n\nvar是一把双刃剑，使用得当会有效提升代码的可读性，使用不好则会让代码可读性变得更差。以下是一些使用建议：\n\n变量命名中提供了足够的信息\n&#x2F;&#x2F; 显式类型\nList&lt;User&gt; list &#x3D; obj.handle();\n\n&#x2F;&#x2F; var方式\nvar userList &#x3D; obj.handle();\n\n变量初始化过程中包含了足够的信息\n&#x2F;&#x2F; 显式类型\nByteArrayOutputStream outputStream &#x3D; new ByteArrayOutputStream();\nList&lt;String&gt; stringList &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\n&#x2F;&#x2F; var方式\nvar outputStream &#x3D; new ByteArrayOutputStream();\nvar stringList &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\n\nfor循环或try-with-resources中，可以考虑使用var\n&#x2F;&#x2F; 显式类型\nfor (Iterator&lt;String&gt; iterator &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).iterator(); iterator.hasNext();) &#123;\n    String string &#x3D; iterator.next();\n&#125;\n&#x2F;&#x2F; var方式\nfor (var iterator &#x3D; List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).iterator(); iterator.hasNext();) &#123;\n    var userType &#x3D; iterator.next();\n&#125;\n\n\nvar的错误用法\nvar a; &#x2F;&#x2F; 没有初始化变量\nvar b &#x3D; null; &#x2F;&#x2F; 不能初始化为null\npublic var c &#x3D; &quot;d&quot;; &#x2F;&#x2F; 不能用于非局部变量\nvar e &#x3D; (String s) -&gt; s.length() &gt; 1; &#x2F;&#x2F; lambda表达式需要显式类型信息\nvar arr &#x3D; &#123;1, 2, 3&#125; &#x2F;&#x2F; 不能用于数组初始化\n\nJava111. String新方法1.1  repeat()\n将字符串重复n次\n\nString text &#x3D; &quot;呼&quot;.repeat(2) + &quot;大睡&quot;;\nSystem.out.println(text);\n\n&gt;&gt;&gt; &quot;呼呼大睡&quot;\n\n1.2  strip系列方法\n去除头尾的空格，包括strip(), stripLeading(), stripTrailing()三个方法。\n\nString text &#x3D; &quot;\\n\\t  hello  \\u2005\\u001C&quot;;\nSystem.out.println(text.strip().equals(&quot;hello&quot;));\n\n&gt;&gt;&gt; true\n\n\n与trim()的不同点\ntrim() 方法判断空格的依据是Unicode代码小于或等于空格符(U+0020)，包括常见的换行符和Tab。\nstrip() 方法的判断依据是Character.isWhitespace()方法，即Unicode空白字符串，范围更广。\n\n\n\n1.3  isBlank()方法\n判断字符串是否为空或只包含空格，空格的判断与strip()相同。\n\nString text &#x3D; &quot;\\n\\t\\u2005  &quot;;\nSystem.out.println(&quot;\\n\\t\\u2005  &quot;.isBlank());\n\n&gt;&gt;&gt; true\n\n1.4  lines() 方法\n通过行终止符(\\n, \\r或\\r\\n)分割字符串，并返回一个 Stream。\n\nString text &#x3D; &quot;每天\\n都能\\r准时\\r\\n下班&quot;;\nList&lt;String&gt; lines &#x3D; text.lines().collect(Collectors.toList());\nSystem.out.println(lines);\n\n&gt;&gt;&gt; [每天, 都能, 准时, 下班]\n\n2. Http Client\nJava11 提供了新的Http客户端，实现了Http和WebSocket的客户端API标准化。\n\n新的 API 为 HTTP 1.1&#x2F;2和WebSocket 提供了原生支持。提供核心功能的核心类和接口包括：\n\nHttpClient类，java.net.http.HttpClient\n\nHttpRequest类，java.net.http.HttpRequest\n\nHttpResponse 接口，java.net.http.HttpResponse\n\nWebSocket接口，java.net.http.WebSocket\n\n\n\n\n&#x2F;&#x2F; 创建 httpRequest\nHttpRequest request &#x3D; HttpRequest.newBuilder()\n    .uri(new URI(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;test&#x2F;1&quot;))\n    .header(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;)\n    .header(&quot;Accept&quot;, &quot;application&#x2F;json&quot;)\n    .timeout(Duration.ofSeconds(10))\n    .POST(HttpRequest.BodyPublishers.ofString(&quot;&#123;\\&quot;score\\&quot;:\\&quot;1\\&quot;&#125;&quot;))\n    .build();\n&#x2F;&#x2F; 创建 httpClient\nHttpClient client &#x3D; HttpClient.newHttpClient();\n&#x2F;&#x2F; 由httpClient发送请求，获取响应数据\nHttpResponse&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());\nHttpHeaders headers &#x3D; response.headers();\nString body &#x3D; response.body();\n\n\n\n3. Java文件运行方式Java11之前需要用javac编译源文件\n$ javac HelloWorld.java\n$ java HelloWorld\n\nHello Java 8!\n\n现在可以直接运行Java文件\n$ java HelloWorld.java\n\nHello Java 11!\n\n4. OpenJDK\nJava11 开始，Oracle JDK 与 OpenJDK 已没有本质的区别\n\n参考资料：\n\nWhat Modules Are About\nThe State of the Module System\nJava9新特性中的模块化到底是什么\nIntroduction to Project Jigsaw\n局部变量类型推断风格指南\n\n","slug":"Java8-17 新特性（二）","date":"2023-02-17T08:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"a4afb430c2cbd3b47233ae51001f2621","title":"Java8-17 新特性（一）","content":"Java8-17 新特性（一）Java81. 接口默认方法和静态方法\n1.1 默认方法默认方法需要用新的关键字default来定义。默认方法可以通过实现类的实例进行访问，并且可以被重写。\npublic interface UserDao &#123;\n    default Optional&lt;User&gt; getUserByUsername(String username) &#123;\n        User user &#x3D; new User();\n        user.setUsername(username);\n        return Optional.of(user);\n    &#125;\n&#125;\n\n1.2 静态方法静态方法不能被重写。\npublic interface UserDao &#123;\n    \n    static Optional&lt;User&gt; getUser(String username) &#123;\n        return Optional.of(new User());\n    &#125;\n&#125;\n\n2. 函数式接口\n函数式接口是指只包含一个抽象方法的接口。函数式接口可以存在多个默认方法，因为它并不是抽象方法。\n\n函数式接口一般通过@FunctionalInterface来声明，但该注解并不是必须的，只要符合上述定义的接口都会被编译器认为是函数式接口。\n\n函数式接口的实例可以通过lambda表达式、方法引用或构造函数引用来创建。\n\n函数式接口有几种基础的形态：\n\nFunction —— 一元函数，接受一个参数并返回一个结果\nConsumer —— 一元函数，接受一个参数，但不返回任何结果\nPredicate —— 一元函数，表示一个参数的断言，返回布尔值\nSupplier —— 零元函数，结果的提供者，不接受参数，只返回结果\n\n\n特定的前缀表示了对基础形态特定的扩展\n\n带元数的前缀，比如Bi前缀，代表二元函数(binary function)，BiConsumer代表接受两个参数，但不返回任何结果\n带类型的前缀，分两种，前缀如果是ToXxx，代表返回值类型是Xxx，否则代表入参的类型。例如ObjIntConsumer代表接受一个泛型参数和int类型参数，ToIntFunction表示返回值是int类型。\n其他派生函数，包括UnaryOperator(extends Function)和BinaryOperator(extends BiFunction)，这两种函数输入值与输出值的类型是一致的。\n\n\n\n\n3. Lambda表达式3.1 lambda表达式\nlambda 表达式是一个可传递的代码块，也被称为闭包(closures)或匿名方法(anonymous methods)。\n\nlambda具有更强的表现力和更简洁的代码，使我们更加关注做什么而非怎么做。\n\nlambda 本质上由三部分组成：一组带括号的参数、一个箭头和一个主体，它可以是单个表达式或 Java 代码块。\nRunnable r &#x3D; () -&gt; &#123;&#125;;\n\n3.2 方法引用方法引用是一种特殊类型的 lambda 表达式。它们通常用于通过引用现有方法来创建简单的 lambda 表达式。\n方法引用有四种：\n\n静态方法\n&#x2F;&#x2F; System.out.println(&quot;&quot;);\nList.of(&quot;a&quot;, &quot;b&quot;).forEach(System.out::println);\n\n特定对象的实例方法\npublic class Comparator &#123;\n    public int compare(User a, User b) &#123;\n        return a.getAge().compareTo(b.getAge());\n    &#125;\n&#125;\n\n@Data\npublic class User &#123;\n    public User() &#123;\n    &#125;\n    public User(String username, Integer age) &#123;\n        this.username &#x3D; username;\n        this.age &#x3D; age;\n    &#125;\n    private String username;\n    private Integer age;\n\n    public static void main(String[] args) &#123;\n        Comparator comparator &#x3D; new Comparator();\n        List&lt;User&gt; list &#x3D; Stream.of(new User(&quot;a&quot;, 42), new User(&quot;b&quot;, 23))\n                .sorted(comparator::compare)\n                .collect(Collectors.toList());\n        System.out.println(list);\n    &#125;\n&#125;\n&gt;&gt;&gt; [User(username&#x3D;b, age&#x3D;23), User(username&#x3D;a, age&#x3D;42)]\n\n\n\n特定类型的任意对象的实例方法\n&#x2F;&#x2F; &quot;a&quot;.toUpperCase();\nList&lt;String&gt; list &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;).map(String::toUpperCase).collect(Collectors.toList());\nSystem.out.println(list);\n\n\n\n构造函数\n@Data\npublic class User &#123;\n    public User() &#123;\n    &#125;\n    public User(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n    private String username;\n&#125;\n\npublic static void main(String[] args) &#123;\n    List&lt;User&gt; list &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;).map(User::new).collect(Collectors.toList());\n    System.out.println(list);\n&#125;\n\n4. Streams\nJava的流(Stream)，遵循“做什么而非怎么做”的原则。\n\n流管道包括一个源（数组、集合、生成器函数、I&#x2F;O通道等）、零个或多个中间操作（intermediate operation，将一个流转换为另一个流）和一个终端操作（产出结果）\n\n流是惰性的，仅在启动终端操作时才对源数据进行计算，并且仅在需要时使用源数据\nStream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)\n    .filter(s -&gt; &#123;\n        System.out.println(&quot;filter: &quot; + s);\n        return s.startsWith(&quot;a&quot;); \n    &#125;)\n    .map(s -&gt; &#123;\n        System.out.println(&quot;map: &quot; + s);\n        return s.toUpperCase();\n    &#125;)\n    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));\n\n\n\nStream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)\n    .sorted((s1, s2) -&gt; &#123;\n        System.out.printf(&quot;sort: %s; %s\\n&quot;, s1, s2);\n        return s1.compareTo(s2); \n    &#125;) \n    .filter(s -&gt; &#123;\n        System.out.println(&quot;filter: &quot; + s);\n        return s.startsWith(&quot;a&quot;); \n    &#125;)\n    .map(s -&gt; &#123;\n        System.out.println(&quot;map: &quot; + s);\n        return s.toUpperCase(); \n    &#125;)\n    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));\n\n&#x2F;&#x2F; 第一个结果\nfilter: d2\nfilter: a2\nmap: a2\nforEach: A2\nfilter: b1\nfilter: b3\nfilter: c\n\n&#x2F;&#x2F; 第二个结果\nsort: a2; d2\nsort: b1; a2\nsort: b1; d2\nsort: b1; a2\nsort: b3; b1\nsort: b3; d2\nsort: c; b3\nsort: c; d2\nfilter: a2\nmap: a2\nforEach: A2\nfilter: b1\nfilter: b3\nfilter: c\nfilter: d2\n\n流是不能被复用的，一旦你调用任何终端操作，流就会关闭\n\n常用的中间操作有：filter, map, flatMap, sorted, peek, limit, skip, distinct等\n\n常用的终端操作有：forEach, toArray, reduce, collect, min, max, findFirst, count, anyMatch等\nList&lt;List&lt;String&gt;&gt; list &#x3D; List.of(List.of(&quot;a&quot;, &quot;b&quot;), List.of(&quot;c&quot;, &quot;d&quot;));\nlist.stream()\n    .flatMap(l -&gt; &#123;\n            System.out.println(&quot;flat map: &quot; + l);\n            return l.stream();\n        &#125;)\n        .map(s -&gt; &#123;\n            System.out.println(&quot;map: &quot; + s);\n            return s.toUpperCase();\n        &#125;)\n        .forEach(System.out::println);\n\n&gt;&gt;&gt; flat map: [a, b]\nmap: a\nA\nmap: b\nB\nflat map: [c, d]\nmap: c\nC\nmap: d\nD\n\n5. Optional&lt;T&gt;\nOptional为空指针(NPE)问题提供了一种解决方案。它用Optional.empty()取代null，以避免null值的判断。\nJava 发布Optional的目的 是将其用作返回类型，从而表明方法可以返回空值。这显式地指出了可能的空指针问题。建议可能为null的返回值都使用Optional。\n类的内部不要使用Optional。\n集合内不要放置Optional对象，也不要用作map的key。\n不要直接调用 get()方法，应当先判断值是否存在或者调用orElseThrow()，orElse()或orElseGet()方法。\n\n6. Date&#x2F;Time API6.1 与原有api的对比新的API遵循ISO 8601标准，设计更加清晰，简化了日期和时间的处理。新API的设计借鉴了第三方库JodaTime。\n\n线程安全问题。新API中所有的日期时间都是不可变的，因此是线程安全的。Date和Calendar的值都是可以直接被修改的，可能出现潜在的线程安全问题。\n\n原有API有一些糟糕的设计，例如java.util.date年份从 1900 开始，月份从 0开始，日期从 1 开始。打印信息可读性较差。新的api则非常清晰。\nDate date &#x3D; new Date(2023, 2, 15);\nSystem.out.println(date);\n&gt;&gt;&gt; Thu Mar 15 00:00:00 CST 3923\n\nCalendar calendar &#x3D; Calendar.getInstance();\ncalendar.set(2023, 2, 15);\nSystem.out.println(calendar.getTime());\n&gt;&gt;&gt; Wed Mar 15 10:55:20 CST 2023\n\nvar localDateTime &#x3D; LocalDateTime.of(2023, 2, 15, 11, 13, 45);\nSystem.out.println(localDateTime);\n&gt;&gt;&gt; 2023-02-15T11:13:45\n\n新的api可以使用不同的日历系统。\n\n\n6.2 新的日期&#x2F;时间API\nInstant——代表一个时间点（timestamp）\nLocalDate——代表本地日期（年、月、日）\nLocalDateTime – 本地日期时间，时间为纳秒精度\nOffsetDateTime – 具有时区偏移的日期时间\nLocalTime – 具有纳秒精度且没有日期信息的时间\nZonedDateTime – 与OffsetDateTime类似，但包括时区 ID\nOffsetLocalTime – 与LocalTime类似，但具有时区偏移\nMonthDay – 月份和日期，没有年份或时间\nYearMonth – 月份和年份，没有日期或时间\nDuration——以秒、分钟和小时表示的时间量。具有纳秒精度\nPeriod——以天、月和年表示的时间量\n\n6.3 常用操作LocalDateTime可以认为是LocalDate+LocalTime，这里以LocalDateTime为例。\n\nLocalDateTime\n&#x2F;&#x2F; 指定日期时间\nvar localDateTime &#x3D; LocalDateTime.of(2023, 2, 15, 11, 13, 45);\n&#x2F;&#x2F; 当前日期时间\nvar now &#x3D; LocalDateTime.now();\n&#x2F;&#x2F; 获取年份\nint year &#x3D; now.getYear();\n&#x2F;&#x2F; 获取月份\nMonth month &#x3D; now.getMonth();\n&#x2F;&#x2F; 获取日期\nint day &#x3D; now.getDayOfMonth();\n&#x2F;&#x2F; 获取星期几\nDayOfWeek dayOfWeek &#x3D; now.getDayOfWeek();\n&#x2F;&#x2F;获取小时\nint hour &#x3D; now.getHour();\n&#x2F;&#x2F;获取分\nint minute &#x3D; now.getMinute();\n&#x2F;&#x2F;获取秒\nint second &#x3D; now.getSecond();\n&#x2F;&#x2F; 以上日期时间也可以通过枚举类ChronoField获取\nint month1 &#x3D; now.get(ChronoField.MONTH_OF_YEAR);\n\nInstant\n&#x2F;&#x2F; 当前时间点\nInstant instant &#x3D; Instant.now();\n&#x2F;&#x2F; 时间戳\nlong seconds &#x3D; instant.getEpochSecond();\nlong milliseconds &#x3D; instant.toEpochMilli();\n\n时间格式化\nvar datetimeFormatter &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\nString formatTime &#x3D; LocalDateTime.now().format(datetimeFormatter);\nvar parseTime &#x3D; LocalDateTime.parse(&quot;2023-02-11 11:20:12&quot;, datetimeFormatter);\n\n对日期时间的操作\n&#x2F;&#x2F; 可以用with*方法修改时间\nLocalDateTime happyTime &#x3D; LocalDateTime.now().withHour(18).withMinute(0).withSecond(0);\nSystem.out.println(happyTime);\n&gt;&gt;&gt; 2023-02-15T18:00:00.909434200\n&#x2F;&#x2F; 可以用TemporalAdjusters修改时间，比如获取当月最后一天\nLocalDateTime lastDayOfMonth &#x3D; LocalDateTime.now().with(TemporalAdjusters.lastDayOfMonth());\nSystem.out.println(lastDayOfMonth);\n&gt;&gt;&gt; 2023-02-28T13:50:46.909434200\n&#x2F;&#x2F; 获取下一个周五的时间\nLocalDateTime nextFriday &#x3D; LocalDateTime.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY));\nSystem.out.println(nextFriday);\n&gt;&gt;&gt; 2023-02-17T13:50:46.910434500\n&#x2F;&#x2F; 10天后，可以直接调用plusDays方法\nLocalDateTime afterTenDays &#x3D; LocalDateTime.now().plusDays(10);\nSystem.out.println(afterTenDays);\n&gt;&gt;&gt; 2023-02-20T13:55:20.574507300\n&#x2F;&#x2F; 10天前，除了minusDays，也可以手动指定单位\nLocalDateTime beforeTenDays &#x3D; LocalDateTime.now().minus(10, ChronoUnit.DAYS);\n\n参考资料：\n\nNew Features in Java 8\n\nJava SE 8 Optional, a pragmatic approach\n\n\n","slug":"Java8-17 新特性（一）","date":"2023-02-17T07:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"f2f9e3dbcdd8dee08b2c8bdbc160f6ea","title":"树型结构","content":"树型结构&#x2F;**\n\n * 获取组织机构树\n\n *\n\n * @author yuxuange\n\n * @Date 2021-02-03\n\n *&#x2F;\n\n@Component\n\npublic class TreeUtil &#123;\n\n    &#x2F;**\n\n     * 组织机构表，根节点CODE\n\n     *&#x2F;\n\n    private static final String TREE_ROOT_CODE &#x3D; &quot;0&quot;;\n\n &#x2F;**\n\n  * 标准版\n\n  *&#x2F;\n\n    public static List&lt;TreeVO&gt; getTree(List&lt;SysDept&gt; record) &#123;\n\n        List&lt;TreeVO&gt; treeList &#x3D; new LinkedList();\n\n        for (SysDept sysDept : record) &#123;\n\n            if (TREE_ROOT_CODE.equals(sysDept.getParentId())) &#123;\n\n                TreeVO treeVO &#x3D; new TreeVO();\n\n                treeVO.setId(sysDept.getCode());\n\n                treeVO.setTitle(sysDept.getName());\n\n                treeVO.setChildren(getChild(sysDept.getCode(), record));\n\n                treeList.add(treeVO);\n\n            &#125;\n\n        &#125;\n\n        return treeList;\n\n    &#125;\n\n    private static List&lt;TreeVO&gt; getChild(String code, List&lt;SysDept&gt; record) &#123;\n\n        List&lt;TreeVO&gt; childrenList &#x3D; new LinkedList();\n\n        for (SysDept sysDept : record) &#123;\n\n            if (code.equals(sysDept.getParentId())) &#123;\n\n                TreeVO treeVO &#x3D; new TreeVO();\n\n                treeVO.setId(sysDept.getCode());\n\n                treeVO.setTitle(sysDept.getName());\n\n                treeVO.setChildren(getChild(sysDept.getCode(), record));\n\n                childrenList.add(treeVO);\n\n            &#125;\n\n        &#125;\n\n        return childrenList;\n\n    &#125;\n\n &#x2F;**\n\n  * lamda表达式版\n\n  *&#x2F;\n\n    public static List&lt;TreeVO&gt; getTreeEX(List&lt;SysDept&gt; record)&#123;\n\n        return record.stream().filter(sysDept -&gt; &#123;return TREE_ROOT_CODE.equals(sysDept.getParentId());&#125;).map(sysDept -&gt; &#123;\n\n            TreeVO treeVO &#x3D; new TreeVO();\n\n            treeVO.setId(sysDept.getCode());\n\n            treeVO.setTitle(sysDept.getName());\n\n            treeVO.setChildren(getChildEX(sysDept.getCode(),record));\n\n            return treeVO;\n\n        &#125;).collect(Collectors.toList());\n\n    &#125;\n\n    private static List&lt;TreeVO&gt; getChildEX(String code,List&lt;SysDept&gt; record)&#123;\n\n        return record.stream().filter(sysDept -&gt; &#123;return code.equals(sysDept.getParentId());&#125;).map(sysDept -&gt; &#123;\n\n            TreeVO treeVO &#x3D; new TreeVO();\n\n            treeVO.setId(sysDept.getCode());\n\n            treeVO.setTitle(sysDept.getName());\n\n            treeVO.setChildren(getChildEX(sysDept.getCode(),record));\n\n            return treeVO;\n\n        &#125;).collect(Collectors.toList());\n\n    &#125;\n\n&#125;\n\n\ncsdn原文\n","slug":"树型结构","date":"2022-08-10T02:33:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"6543d025a348af299ba6e8174ff95a54","title":"Java创建List的四种方法","content":"Java创建List常用几种方式1、常规操作 new ArrayList&lt;&gt;() 创建\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(3);\n2、Arrays工具类创建\nList&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3);\nArrays.asList() 方法是 Arrays 的静态方法。这种方式构造的 List 是固定长度的，如果调用 add 方法增加新的元素时会报异常 java.lang.UnsupportedOperationException。这种方式仅适用于构造静态不变的 List。如果想要改变可以通过 ArrayLis t进行包装成动态。\nList&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3);\nlist &#x3D; new ArrayList&lt;&gt;(list);\nlist.add(4);\n3、Stream创建\nList&lt;Integer&gt; list &#x3D; Stream.of(1, 2, 3).collect(Collectors.toList());\n4、匿名内部类创建\nList&lt;Integer&gt; list&#x3D; new ArrayList() &#123;&#123;\n    add(1);\n    add(2);\n    add(3);\n&#125;&#125;;\n5、Hutool工具类创建\nList&lt;Integer&gt; list &#x3D; CollectionUtil.newArrayList(1, 2, 3);\n6、guava工具类创建\nimport com.google.common.collect.Lists;\n\nList&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3);\n7、JDK9 引入的Lists创建\nList&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3);\n8、JDK9引入 List.of (不可变)\nList&lt;Integer&gt; list &#x3D; List.of(1,2,3);\n","slug":"Java创建List的四种方法","date":"2022-06-22T02:03:42.000Z","categories_index":"Java","tags_index":"Java","author_index":"小海"},{"id":"3a82a96064298ae3557311afb39a2155","title":"linux 查看防火墙状态","content":"linux 查看防火墙状态1.查看防火墙状态\nsystemctl status firewalld\nfirewall-cmd –state #查看默认防火墙状态(关闭后显示notrunning，开启后显示running)\n2.查看防火墙是否开机启动\nsystemctl is-enabled firewalld\n3.关闭防火墙\nsystemctl stop firewalld\nsystemctl stop firewalld.service\nsystemctl status firewalld\n4.禁用防火墙(系统启动时不启动防火墙服务)\nsystemctl disable firewalld\nsystemctl disable firewalld.service\nsystemctl is-enabled firewalld\n","slug":"linux 查看防火墙状态","date":"2022-05-17T08:43:42.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"小海"},{"id":"4122a09df2e4f3d18921791a0dcc0507","title":"docker","content":"docker更新 yum我们会通过 yum 来安装 Docker, 所以首先更新 yum\nyum -y update\n安装docker接着就是安装 Docker\nyum install docker -y\n仅仅安装了还不行，还要启动\nsystemctl start docker.service\nsystemctl status docker.service\n设置docker开机自启\nsystemctl enable docker\n\n看到那个 active 就表示已经在运行啦以下是docker 的生命周期管理常用命令：\nsystemctl stop docker.service\nsystemctl start docker.service\nsystemctl restart docker.service\nsystemctl status docker.service\n镜像管理\n1. search 查看仓库里有些什么镜像\ndocker search tomcat\n会出来很多，那么到底应该用哪个呢？\n这时，就打开 hub.docker.com ，然后搜索 tomcat。 或者点击如下链接\nhttps://hub.docker.com/search?q=tomcat&amp;type=image\n可以看到更多的 tomcat了。\n而第一个，就是docker 官网提供的 tomcat了，一般就用他了吧。。。\n2. pull 拉取镜像\ntomcat 又有很多版本，到底选哪个呢？\n点击官网的 Tomcat 镜像，然后点击 tag，就发现又有很多版本\nhttps://hub.docker.com/_/tomcat?tab=tags那么就选一个自己当前需要的吧。 比如我要用 8.0 的话，那么就执行如下命令\ndocker pull tomcat:8.0\n\n不同镜像的用法不一样，在它的描述里都有详细讲解如何启动等等信息：\nhttps://hub.docker.com/_/tomcat?tab=description&amp;page=2\n比如这个8.0,按照官方指导启动办法：\ndocker run -it --rm -p 8888:8080 tomcat:8.0\n\n\n这个 –rm 表示如果容器已经存在了，自动删除容器\n最后访问： http:&#x2F;&#x2F;:8888 就可以正常访问了\n3. images 查看本地有些什么镜像\ndocker images\n4. rmi 删除本地镜像\ndocker images\ndocker rmi docker.io&#x2F;tomcat:8.0\n有时候为了调试，需要不厌其烦地删除镜像，下面这句话就会自动删除所有镜像啦\ndocker rmi $(docker images -q)\n5. 修改本地镜像名称 tag\n通过tag可以对镜像进行标记，如图所示，把 docker.io&#x2F;tomcat:8.0 标记成了docker.io&#x2F;mytomcat:8.0\ndocker tag docker.io&#x2F;tomcat:8.0 docker.io&#x2F;mytomcat:8.0\n\n这样 image_id&#x3D; “ef6a7c98d192” 的镜像，就有两个标记了，分别是docker.io&#x2F;tomcat:8.0docker.io&#x2F;mytomcat:8.0\n6. push , 把镜像提交到仓库\n注册账号\n仓库位于 hub.docker.com 上，为了提交新的镜像，肯定要有账号才行，所以第一步是注册账号。\n登录这里说的登录，不是在 hub.docker.com 网站上，而是在 docker 后台进行登录。执行命令：\ndocker login\n然后输入账号密码就行了。\n注意，账号不是邮箱地址哦\npush\n推送镜像到仓库首先镜像命名要符合 aaa&#x2F;bbb 这样的风格，即斜杠前面必须是你的账号名,冒号后为版本 如果镜像不是这个名字，可以通过 tag进行标记。 \ndocker push aaa&#x2F;bbb:8.0\n\n耗时多久，取决于你的镜像大小~\n容器管理\n\n运行 run\n\ndocker run --name some-mysql -v ~&#x2F;.halo&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql --privileged&#x3D;true -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw --net halo-net --restart&#x3D;unless-stopped -d mysql:8.0.27\n\n–name： 为容器指定一个名称\n\n\n-v ~&#x2F;.halo&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql 命令: 将宿主机的目录 ~&#x2F;.halo&#x2F;mysql 挂载到容器内部的目录 &#x2F;var&#x2F;lib&#x2F;mysql，默认情况下 MySQL 将向 ~&#x2F;.halo&#x2F;mysql 写入其数据文件。\n\n\n-p： 端口映射，格式为 主机(宿主)端口:容器端口 ，可在 application.yaml 配置。\n-e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw: 指定MySQL的登录密码为 my-secret-pw\n–net halo-net: 将该容器加入到 halo-net 网络,连接到 halo-net 网络的任何其他容器都可以访问 some-mysql容器上的所有端口。\n–restart： 建议设置为 unless-stopped，在 Docker 启动的时候自动启动 some-mysql 容器。\n-dit 是 -d -i -t 的缩写。 -d ，表示 detach，即在后台运行。 -i 表示提供交互接口，这样才可以通过 docker 和 跑起来的操作系统交互。 -t 表示提供一个 tty (伪终端)，与 -i 配合就可以通过 ssh 工具连接到 这个容器里面去了\n–privileged 启动容器的时候，把权限带进去。 这样才可以在容器里进行完整的操作\n\n\n\n\n\n\n\n\n\n\nCentos7的安全Selinux禁止了一些安全权限，导致挂载信息时出出现权限不足，run命令行添加 –privileged&#x3D;true\n\n进入 exec attach\n\n  some-mysql 为 MySQL 实例的容器名称\ndocker exec -it some-mysql &#x2F;bin&#x2F;bash\n\n\n生命周期管理， 暂停，恢复，停止，启动 pause, unpause, stop, start\n\n暂停：pause\n恢复：unpause\n停止：stop\n开始：start\n\nps 查看所有的容器查询所有的容器docker ps\n查询查询 run 状态的和 pause 状态的， stop状态的就不会查询出来了docker ps -a\n检查某个具体的容器  inspect\n\n检查这个容器里的各项信息，\ndocker inspect some-mysql\n\nrm 删除容器\n\n删除容器，与删除镜像 rmi 命令遥相呼应。。。。\ndocker rm some-mysql\n\n在运行中的 容器是不能删除的，要先 stop ,然后再删除。\n\ncommit，对容器做了修改后，把改动后的容器，再次转换为镜像\ncommit 很有意思了，因为它的作用就是把一个活生生的容器，再转换为镜像。\n使用办法：\n\n\ndocker commit some-mysql new-mysql:now\n","slug":"docker","date":"2022-05-12T07:33:42.000Z","categories_index":"docker","tags_index":"docker","author_index":"小海"},{"id":"c3fe4d98af02bf9a9f9237331aef4bd4","title":"win cmd卸载命令","content":"win cmd卸载命令\n在窗口中输入 ：wmic 然后回车\n输入product list 回车让然后稍微等待一会\n找到需要卸载程序的IdentfyingNUmber\n输入exit 退出wmic\n输入msiexec&#x2F;x + 刚才复制的Number\n确定即可\n\n","slug":"win cmd卸载命令","date":"2022-05-07T02:42:42.000Z","categories_index":"windows","tags_index":"windows","author_index":"小海"}]